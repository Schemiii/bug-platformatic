// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./api-types.d.ts').Api['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./api-types.d.ts').Api['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _importDbGetFile (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.documentType.eq', 'where.documentType.neq', 'where.documentType.gt', 'where.documentType.gte', 'where.documentType.lt', 'where.documentType.lte', 'where.documentType.like', 'where.documentType.in', 'where.documentType.nin', 'where.documentType.contains', 'where.documentType.contained', 'where.documentType.overlaps', 'where.encoding.eq', 'where.encoding.neq', 'where.encoding.gt', 'where.encoding.gte', 'where.encoding.lt', 'where.encoding.lte', 'where.encoding.like', 'where.encoding.in', 'where.encoding.nin', 'where.encoding.contains', 'where.encoding.contained', 'where.encoding.overlaps', 'where.hash.eq', 'where.hash.neq', 'where.hash.gt', 'where.hash.gte', 'where.hash.lt', 'where.hash.lte', 'where.hash.like', 'where.hash.in', 'where.hash.nin', 'where.hash.contains', 'where.hash.contained', 'where.hash.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.mimetype.eq', 'where.mimetype.neq', 'where.mimetype.gt', 'where.mimetype.gte', 'where.mimetype.lt', 'where.mimetype.lte', 'where.mimetype.like', 'where.mimetype.in', 'where.mimetype.nin', 'where.mimetype.contains', 'where.mimetype.contained', 'where.mimetype.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.path.eq', 'where.path.neq', 'where.path.gt', 'where.path.gte', 'where.path.lt', 'where.path.lte', 'where.path.like', 'where.path.in', 'where.path.nin', 'where.path.contains', 'where.path.contained', 'where.path.overlaps', 'where.type.eq', 'where.type.neq', 'where.type.gt', 'where.type.gte', 'where.type.lt', 'where.type.lte', 'where.type.like', 'where.type.in', 'where.type.nin', 'where.type.contains', 'where.type.contained', 'where.type.overlaps', 'where.or', 'orderby.documentType', 'orderby.encoding', 'orderby.hash', 'orderby.id', 'orderby.mimetype', 'orderby.name', 'orderby.path', 'orderby.type']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/file/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFile']} */
export const importDbGetFile = async (request) => {
  return await _importDbGetFile(baseUrl, request)
}
async function _importDbCreateFile (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/file/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbCreateFile']} */
export const importDbCreateFile = async (request) => {
  return await _importDbCreateFile(baseUrl, request)
}
async function _importDbUpdateFile (url, request) {
  const queryParameters = ['fields', 'where.documentType.eq', 'where.documentType.neq', 'where.documentType.gt', 'where.documentType.gte', 'where.documentType.lt', 'where.documentType.lte', 'where.documentType.like', 'where.documentType.in', 'where.documentType.nin', 'where.documentType.contains', 'where.documentType.contained', 'where.documentType.overlaps', 'where.encoding.eq', 'where.encoding.neq', 'where.encoding.gt', 'where.encoding.gte', 'where.encoding.lt', 'where.encoding.lte', 'where.encoding.like', 'where.encoding.in', 'where.encoding.nin', 'where.encoding.contains', 'where.encoding.contained', 'where.encoding.overlaps', 'where.hash.eq', 'where.hash.neq', 'where.hash.gt', 'where.hash.gte', 'where.hash.lt', 'where.hash.lte', 'where.hash.like', 'where.hash.in', 'where.hash.nin', 'where.hash.contains', 'where.hash.contained', 'where.hash.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.mimetype.eq', 'where.mimetype.neq', 'where.mimetype.gt', 'where.mimetype.gte', 'where.mimetype.lt', 'where.mimetype.lte', 'where.mimetype.like', 'where.mimetype.in', 'where.mimetype.nin', 'where.mimetype.contains', 'where.mimetype.contained', 'where.mimetype.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.path.eq', 'where.path.neq', 'where.path.gt', 'where.path.gte', 'where.path.lt', 'where.path.lte', 'where.path.like', 'where.path.in', 'where.path.nin', 'where.path.contains', 'where.path.contained', 'where.path.overlaps', 'where.type.eq', 'where.type.neq', 'where.type.gt', 'where.type.gte', 'where.type.lt', 'where.type.lte', 'where.type.like', 'where.type.in', 'where.type.nin', 'where.type.contains', 'where.type.contained', 'where.type.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/file/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbUpdateFile']} */
export const importDbUpdateFile = async (request) => {
  return await _importDbUpdateFile(baseUrl, request)
}
async function _importDbGetFileById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/file/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileById']} */
export const importDbGetFileById = async (request) => {
  return await _importDbGetFileById(baseUrl, request)
}
async function _importDbUpdateFile (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/file/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbUpdateFile']} */
export const importDbUpdateFile = async (request) => {
  return await _importDbUpdateFile(baseUrl, request)
}
async function _importDbDeleteFile (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/file/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbDeleteFile']} */
export const importDbDeleteFile = async (request) => {
  return await _importDbDeleteFile(baseUrl, request)
}
async function _importDbGetFileExtractionForFile (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/file/${request['id']}/fileExtraction?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileExtractionForFile']} */
export const importDbGetFileExtractionForFile = async (request) => {
  return await _importDbGetFileExtractionForFile(baseUrl, request)
}
async function _importDbGetFileTrainingForFile (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/file/${request['id']}/fileTraining?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileTrainingForFile']} */
export const importDbGetFileTrainingForFile = async (request) => {
  return await _importDbGetFileTrainingForFile(baseUrl, request)
}
async function _importDbGetFileExtraction (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.content.eq', 'where.content.neq', 'where.content.gt', 'where.content.gte', 'where.content.lt', 'where.content.lte', 'where.content.like', 'where.content.in', 'where.content.nin', 'where.content.contains', 'where.content.contained', 'where.content.overlaps', 'where.entities.eq', 'where.entities.neq', 'where.entities.gt', 'where.entities.gte', 'where.entities.lt', 'where.entities.lte', 'where.entities.like', 'where.entities.in', 'where.entities.nin', 'where.entities.contains', 'where.entities.contained', 'where.entities.overlaps', 'where.fileId.eq', 'where.fileId.neq', 'where.fileId.gt', 'where.fileId.gte', 'where.fileId.lt', 'where.fileId.lte', 'where.fileId.like', 'where.fileId.in', 'where.fileId.nin', 'where.fileId.contains', 'where.fileId.contained', 'where.fileId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or', 'orderby.content', 'orderby.entities', 'orderby.fileId', 'orderby.id']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fileExtraction/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileExtraction']} */
export const importDbGetFileExtraction = async (request) => {
  return await _importDbGetFileExtraction(baseUrl, request)
}
async function _importDbCreateFileExtraction (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileExtraction/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbCreateFileExtraction']} */
export const importDbCreateFileExtraction = async (request) => {
  return await _importDbCreateFileExtraction(baseUrl, request)
}
async function _importDbUpdateFileExtraction (url, request) {
  const queryParameters = ['fields', 'where.content.eq', 'where.content.neq', 'where.content.gt', 'where.content.gte', 'where.content.lt', 'where.content.lte', 'where.content.like', 'where.content.in', 'where.content.nin', 'where.content.contains', 'where.content.contained', 'where.content.overlaps', 'where.entities.eq', 'where.entities.neq', 'where.entities.gt', 'where.entities.gte', 'where.entities.lt', 'where.entities.lte', 'where.entities.like', 'where.entities.in', 'where.entities.nin', 'where.entities.contains', 'where.entities.contained', 'where.entities.overlaps', 'where.fileId.eq', 'where.fileId.neq', 'where.fileId.gt', 'where.fileId.gte', 'where.fileId.lt', 'where.fileId.lte', 'where.fileId.like', 'where.fileId.in', 'where.fileId.nin', 'where.fileId.contains', 'where.fileId.contained', 'where.fileId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileExtraction/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbUpdateFileExtraction']} */
export const importDbUpdateFileExtraction = async (request) => {
  return await _importDbUpdateFileExtraction(baseUrl, request)
}
async function _importDbGetFileExtractionById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fileExtraction/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileExtractionById']} */
export const importDbGetFileExtractionById = async (request) => {
  return await _importDbGetFileExtractionById(baseUrl, request)
}
async function _importDbUpdateFileExtraction (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileExtraction/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbUpdateFileExtraction']} */
export const importDbUpdateFileExtraction = async (request) => {
  return await _importDbUpdateFileExtraction(baseUrl, request)
}
async function _importDbDeleteFileExtraction (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileExtraction/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbDeleteFileExtraction']} */
export const importDbDeleteFileExtraction = async (request) => {
  return await _importDbDeleteFileExtraction(baseUrl, request)
}
async function _importDbGetFileForFileExtraction (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fileExtraction/${request['id']}/file?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileForFileExtraction']} */
export const importDbGetFileForFileExtraction = async (request) => {
  return await _importDbGetFileForFileExtraction(baseUrl, request)
}
async function _importDbGetFileTraining (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.fileId.eq', 'where.fileId.neq', 'where.fileId.gt', 'where.fileId.gte', 'where.fileId.lt', 'where.fileId.lte', 'where.fileId.like', 'where.fileId.in', 'where.fileId.nin', 'where.fileId.contains', 'where.fileId.contained', 'where.fileId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.processorPath.eq', 'where.processorPath.neq', 'where.processorPath.gt', 'where.processorPath.gte', 'where.processorPath.lt', 'where.processorPath.lte', 'where.processorPath.like', 'where.processorPath.in', 'where.processorPath.nin', 'where.processorPath.contains', 'where.processorPath.contained', 'where.processorPath.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or', 'orderby.fileId', 'orderby.id', 'orderby.processorPath', 'orderby.status']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fileTraining/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileTraining']} */
export const importDbGetFileTraining = async (request) => {
  return await _importDbGetFileTraining(baseUrl, request)
}
async function _importDbCreateFileTraining (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileTraining/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbCreateFileTraining']} */
export const importDbCreateFileTraining = async (request) => {
  return await _importDbCreateFileTraining(baseUrl, request)
}
async function _importDbUpdateFileTraining (url, request) {
  const queryParameters = ['fields', 'where.fileId.eq', 'where.fileId.neq', 'where.fileId.gt', 'where.fileId.gte', 'where.fileId.lt', 'where.fileId.lte', 'where.fileId.like', 'where.fileId.in', 'where.fileId.nin', 'where.fileId.contains', 'where.fileId.contained', 'where.fileId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.processorPath.eq', 'where.processorPath.neq', 'where.processorPath.gt', 'where.processorPath.gte', 'where.processorPath.lt', 'where.processorPath.lte', 'where.processorPath.like', 'where.processorPath.in', 'where.processorPath.nin', 'where.processorPath.contains', 'where.processorPath.contained', 'where.processorPath.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileTraining/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbUpdateFileTraining']} */
export const importDbUpdateFileTraining = async (request) => {
  return await _importDbUpdateFileTraining(baseUrl, request)
}
async function _importDbGetFileTrainingById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fileTraining/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileTrainingById']} */
export const importDbGetFileTrainingById = async (request) => {
  return await _importDbGetFileTrainingById(baseUrl, request)
}
async function _importDbUpdateFileTraining (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileTraining/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbUpdateFileTraining']} */
export const importDbUpdateFileTraining = async (request) => {
  return await _importDbUpdateFileTraining(baseUrl, request)
}
async function _importDbDeleteFileTraining (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fileTraining/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbDeleteFileTraining']} */
export const importDbDeleteFileTraining = async (request) => {
  return await _importDbDeleteFileTraining(baseUrl, request)
}
async function _importDbGetFileForFileTraining (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fileTraining/${request['id']}/file?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['importDbGetFileForFileTraining']} */
export const importDbGetFileForFileTraining = async (request) => {
  return await _importDbGetFileForFileTraining(baseUrl, request)
}
async function _postImportInvoiceGoods (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/import/invoice/goods`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postImportInvoiceGoods']} */
export const postImportInvoiceGoods = async (request) => {
  return await _postImportInvoiceGoods(baseUrl, request)
}
async function _postImportTrainFileId (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/import/train/${request['fileId']}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postImportTrainFileId']} */
export const postImportTrainFileId = async (request) => {
  return await _postImportTrainFileId(baseUrl, request)
}
async function _postImportModelFileId (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/import/model/${request['fileId']}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postImportModelFileId']} */
export const postImportModelFileId = async (request) => {
  return await _postImportModelFileId(baseUrl, request)
}
async function _fairDbGetProductSupplier (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.bic.eq', 'where.bic.neq', 'where.bic.gt', 'where.bic.gte', 'where.bic.lt', 'where.bic.lte', 'where.bic.like', 'where.bic.in', 'where.bic.nin', 'where.bic.contains', 'where.bic.contained', 'where.bic.overlaps', 'where.city.eq', 'where.city.neq', 'where.city.gt', 'where.city.gte', 'where.city.lt', 'where.city.lte', 'where.city.like', 'where.city.in', 'where.city.nin', 'where.city.contains', 'where.city.contained', 'where.city.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.email.eq', 'where.email.neq', 'where.email.gt', 'where.email.gte', 'where.email.lt', 'where.email.lte', 'where.email.like', 'where.email.in', 'where.email.nin', 'where.email.contains', 'where.email.contained', 'where.email.overlaps', 'where.homepage.eq', 'where.homepage.neq', 'where.homepage.gt', 'where.homepage.gte', 'where.homepage.lt', 'where.homepage.lte', 'where.homepage.like', 'where.homepage.in', 'where.homepage.nin', 'where.homepage.contains', 'where.homepage.contained', 'where.homepage.overlaps', 'where.iban.eq', 'where.iban.neq', 'where.iban.gt', 'where.iban.gte', 'where.iban.lt', 'where.iban.lte', 'where.iban.like', 'where.iban.in', 'where.iban.nin', 'where.iban.contains', 'where.iban.contained', 'where.iban.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.phone.eq', 'where.phone.neq', 'where.phone.gt', 'where.phone.gte', 'where.phone.lt', 'where.phone.lte', 'where.phone.like', 'where.phone.in', 'where.phone.nin', 'where.phone.contains', 'where.phone.contained', 'where.phone.overlaps', 'where.postalCode.eq', 'where.postalCode.neq', 'where.postalCode.gt', 'where.postalCode.gte', 'where.postalCode.lt', 'where.postalCode.lte', 'where.postalCode.like', 'where.postalCode.in', 'where.postalCode.nin', 'where.postalCode.contains', 'where.postalCode.contained', 'where.postalCode.overlaps', 'where.ratingPrice.eq', 'where.ratingPrice.neq', 'where.ratingPrice.gt', 'where.ratingPrice.gte', 'where.ratingPrice.lt', 'where.ratingPrice.lte', 'where.ratingPrice.like', 'where.ratingPrice.in', 'where.ratingPrice.nin', 'where.ratingPrice.contains', 'where.ratingPrice.contained', 'where.ratingPrice.overlaps', 'where.ratingSupply.eq', 'where.ratingSupply.neq', 'where.ratingSupply.gt', 'where.ratingSupply.gte', 'where.ratingSupply.lt', 'where.ratingSupply.lte', 'where.ratingSupply.like', 'where.ratingSupply.in', 'where.ratingSupply.nin', 'where.ratingSupply.contains', 'where.ratingSupply.contained', 'where.ratingSupply.overlaps', 'where.state.eq', 'where.state.neq', 'where.state.gt', 'where.state.gte', 'where.state.lt', 'where.state.lte', 'where.state.like', 'where.state.in', 'where.state.nin', 'where.state.contains', 'where.state.contained', 'where.state.overlaps', 'where.street.eq', 'where.street.neq', 'where.street.gt', 'where.street.gte', 'where.street.lt', 'where.street.lte', 'where.street.like', 'where.street.in', 'where.street.nin', 'where.street.contains', 'where.street.contained', 'where.street.overlaps', 'where.vat.eq', 'where.vat.neq', 'where.vat.gt', 'where.vat.gte', 'where.vat.lt', 'where.vat.lte', 'where.vat.like', 'where.vat.in', 'where.vat.nin', 'where.vat.contains', 'where.vat.contained', 'where.vat.overlaps', 'where.or', 'orderby.bic', 'orderby.city', 'orderby.description', 'orderby.email', 'orderby.homepage', 'orderby.iban', 'orderby.id', 'orderby.name', 'orderby.phone', 'orderby.postalCode', 'orderby.ratingPrice', 'orderby.ratingSupply', 'orderby.state', 'orderby.street', 'orderby.vat']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productSupplier/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductSupplier']} */
export const fairDbGetProductSupplier = async (request) => {
  return await _fairDbGetProductSupplier(baseUrl, request)
}
async function _fairDbCreateProductSupplier (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productSupplier/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateProductSupplier']} */
export const fairDbCreateProductSupplier = async (request) => {
  return await _fairDbCreateProductSupplier(baseUrl, request)
}
async function _fairDbUpdateProductSupplier (url, request) {
  const queryParameters = ['fields', 'where.bic.eq', 'where.bic.neq', 'where.bic.gt', 'where.bic.gte', 'where.bic.lt', 'where.bic.lte', 'where.bic.like', 'where.bic.in', 'where.bic.nin', 'where.bic.contains', 'where.bic.contained', 'where.bic.overlaps', 'where.city.eq', 'where.city.neq', 'where.city.gt', 'where.city.gte', 'where.city.lt', 'where.city.lte', 'where.city.like', 'where.city.in', 'where.city.nin', 'where.city.contains', 'where.city.contained', 'where.city.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.email.eq', 'where.email.neq', 'where.email.gt', 'where.email.gte', 'where.email.lt', 'where.email.lte', 'where.email.like', 'where.email.in', 'where.email.nin', 'where.email.contains', 'where.email.contained', 'where.email.overlaps', 'where.homepage.eq', 'where.homepage.neq', 'where.homepage.gt', 'where.homepage.gte', 'where.homepage.lt', 'where.homepage.lte', 'where.homepage.like', 'where.homepage.in', 'where.homepage.nin', 'where.homepage.contains', 'where.homepage.contained', 'where.homepage.overlaps', 'where.iban.eq', 'where.iban.neq', 'where.iban.gt', 'where.iban.gte', 'where.iban.lt', 'where.iban.lte', 'where.iban.like', 'where.iban.in', 'where.iban.nin', 'where.iban.contains', 'where.iban.contained', 'where.iban.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.phone.eq', 'where.phone.neq', 'where.phone.gt', 'where.phone.gte', 'where.phone.lt', 'where.phone.lte', 'where.phone.like', 'where.phone.in', 'where.phone.nin', 'where.phone.contains', 'where.phone.contained', 'where.phone.overlaps', 'where.postalCode.eq', 'where.postalCode.neq', 'where.postalCode.gt', 'where.postalCode.gte', 'where.postalCode.lt', 'where.postalCode.lte', 'where.postalCode.like', 'where.postalCode.in', 'where.postalCode.nin', 'where.postalCode.contains', 'where.postalCode.contained', 'where.postalCode.overlaps', 'where.ratingPrice.eq', 'where.ratingPrice.neq', 'where.ratingPrice.gt', 'where.ratingPrice.gte', 'where.ratingPrice.lt', 'where.ratingPrice.lte', 'where.ratingPrice.like', 'where.ratingPrice.in', 'where.ratingPrice.nin', 'where.ratingPrice.contains', 'where.ratingPrice.contained', 'where.ratingPrice.overlaps', 'where.ratingSupply.eq', 'where.ratingSupply.neq', 'where.ratingSupply.gt', 'where.ratingSupply.gte', 'where.ratingSupply.lt', 'where.ratingSupply.lte', 'where.ratingSupply.like', 'where.ratingSupply.in', 'where.ratingSupply.nin', 'where.ratingSupply.contains', 'where.ratingSupply.contained', 'where.ratingSupply.overlaps', 'where.state.eq', 'where.state.neq', 'where.state.gt', 'where.state.gte', 'where.state.lt', 'where.state.lte', 'where.state.like', 'where.state.in', 'where.state.nin', 'where.state.contains', 'where.state.contained', 'where.state.overlaps', 'where.street.eq', 'where.street.neq', 'where.street.gt', 'where.street.gte', 'where.street.lt', 'where.street.lte', 'where.street.like', 'where.street.in', 'where.street.nin', 'where.street.contains', 'where.street.contained', 'where.street.overlaps', 'where.vat.eq', 'where.vat.neq', 'where.vat.gt', 'where.vat.gte', 'where.vat.lt', 'where.vat.lte', 'where.vat.like', 'where.vat.in', 'where.vat.nin', 'where.vat.contains', 'where.vat.contained', 'where.vat.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productSupplier/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductSupplier']} */
export const fairDbUpdateProductSupplier = async (request) => {
  return await _fairDbUpdateProductSupplier(baseUrl, request)
}
async function _fairDbGetProductSupplierById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productSupplier/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductSupplierById']} */
export const fairDbGetProductSupplierById = async (request) => {
  return await _fairDbGetProductSupplierById(baseUrl, request)
}
async function _fairDbUpdateProductSupplier (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productSupplier/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductSupplier']} */
export const fairDbUpdateProductSupplier = async (request) => {
  return await _fairDbUpdateProductSupplier(baseUrl, request)
}
async function _fairDbDeleteProductSupplier (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productSupplier/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteProductSupplier']} */
export const fairDbDeleteProductSupplier = async (request) => {
  return await _fairDbDeleteProductSupplier(baseUrl, request)
}
async function _fairDbGetProductForProductSupplier (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productSupplier/${request['id']}/product?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductForProductSupplier']} */
export const fairDbGetProductForProductSupplier = async (request) => {
  return await _fairDbGetProductForProductSupplier(baseUrl, request)
}
async function _fairDbGetProductOrderForProductSupplier (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productSupplier/${request['id']}/productOrder?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrderForProductSupplier']} */
export const fairDbGetProductOrderForProductSupplier = async (request) => {
  return await _fairDbGetProductOrderForProductSupplier(baseUrl, request)
}
async function _fairDbGetProductCategory (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.category.eq', 'where.category.neq', 'where.category.gt', 'where.category.gte', 'where.category.lt', 'where.category.lte', 'where.category.like', 'where.category.in', 'where.category.nin', 'where.category.contains', 'where.category.contained', 'where.category.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or', 'orderby.category', 'orderby.description', 'orderby.id']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productCategory/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductCategory']} */
export const fairDbGetProductCategory = async (request) => {
  return await _fairDbGetProductCategory(baseUrl, request)
}
async function _fairDbCreateProductCategory (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productCategory/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateProductCategory']} */
export const fairDbCreateProductCategory = async (request) => {
  return await _fairDbCreateProductCategory(baseUrl, request)
}
async function _fairDbUpdateProductCategory (url, request) {
  const queryParameters = ['fields', 'where.category.eq', 'where.category.neq', 'where.category.gt', 'where.category.gte', 'where.category.lt', 'where.category.lte', 'where.category.like', 'where.category.in', 'where.category.nin', 'where.category.contains', 'where.category.contained', 'where.category.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productCategory/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductCategory']} */
export const fairDbUpdateProductCategory = async (request) => {
  return await _fairDbUpdateProductCategory(baseUrl, request)
}
async function _fairDbGetProductCategoryById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productCategory/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductCategoryById']} */
export const fairDbGetProductCategoryById = async (request) => {
  return await _fairDbGetProductCategoryById(baseUrl, request)
}
async function _fairDbUpdateProductCategory (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productCategory/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductCategory']} */
export const fairDbUpdateProductCategory = async (request) => {
  return await _fairDbUpdateProductCategory(baseUrl, request)
}
async function _fairDbDeleteProductCategory (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productCategory/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteProductCategory']} */
export const fairDbDeleteProductCategory = async (request) => {
  return await _fairDbDeleteProductCategory(baseUrl, request)
}
async function _fairDbGetProductToProductCategoryForProductCategory (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productCategory/${request['id']}/productToProductCategoryProductCategoryId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductToProductCategoryForProductCategory']} */
export const fairDbGetProductToProductCategoryForProductCategory = async (request) => {
  return await _fairDbGetProductToProductCategoryForProductCategory(baseUrl, request)
}
async function _fairDbGetProduct (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.active.eq', 'where.active.neq', 'where.active.gt', 'where.active.gte', 'where.active.lt', 'where.active.lte', 'where.active.like', 'where.active.in', 'where.active.nin', 'where.active.contains', 'where.active.contained', 'where.active.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.productSupplierId.eq', 'where.productSupplierId.neq', 'where.productSupplierId.gt', 'where.productSupplierId.gte', 'where.productSupplierId.lt', 'where.productSupplierId.lte', 'where.productSupplierId.like', 'where.productSupplierId.in', 'where.productSupplierId.nin', 'where.productSupplierId.contains', 'where.productSupplierId.contained', 'where.productSupplierId.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.unit.eq', 'where.unit.neq', 'where.unit.gt', 'where.unit.gte', 'where.unit.lt', 'where.unit.lte', 'where.unit.like', 'where.unit.in', 'where.unit.nin', 'where.unit.contains', 'where.unit.contained', 'where.unit.overlaps', 'where.or', 'orderby.active', 'orderby.description', 'orderby.id', 'orderby.productSupplierId', 'orderby.title', 'orderby.unit']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/product/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProduct']} */
export const fairDbGetProduct = async (request) => {
  return await _fairDbGetProduct(baseUrl, request)
}
async function _fairDbCreateProduct (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/product/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateProduct']} */
export const fairDbCreateProduct = async (request) => {
  return await _fairDbCreateProduct(baseUrl, request)
}
async function _fairDbUpdateProduct (url, request) {
  const queryParameters = ['fields', 'where.active.eq', 'where.active.neq', 'where.active.gt', 'where.active.gte', 'where.active.lt', 'where.active.lte', 'where.active.like', 'where.active.in', 'where.active.nin', 'where.active.contains', 'where.active.contained', 'where.active.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.productSupplierId.eq', 'where.productSupplierId.neq', 'where.productSupplierId.gt', 'where.productSupplierId.gte', 'where.productSupplierId.lt', 'where.productSupplierId.lte', 'where.productSupplierId.like', 'where.productSupplierId.in', 'where.productSupplierId.nin', 'where.productSupplierId.contains', 'where.productSupplierId.contained', 'where.productSupplierId.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.unit.eq', 'where.unit.neq', 'where.unit.gt', 'where.unit.gte', 'where.unit.lt', 'where.unit.lte', 'where.unit.like', 'where.unit.in', 'where.unit.nin', 'where.unit.contains', 'where.unit.contained', 'where.unit.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/product/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProduct']} */
export const fairDbUpdateProduct = async (request) => {
  return await _fairDbUpdateProduct(baseUrl, request)
}
async function _fairDbGetProductById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/product/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductById']} */
export const fairDbGetProductById = async (request) => {
  return await _fairDbGetProductById(baseUrl, request)
}
async function _fairDbUpdateProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/product/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProduct']} */
export const fairDbUpdateProduct = async (request) => {
  return await _fairDbUpdateProduct(baseUrl, request)
}
async function _fairDbDeleteProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/product/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteProduct']} */
export const fairDbDeleteProduct = async (request) => {
  return await _fairDbDeleteProduct(baseUrl, request)
}
async function _fairDbGetProductToProductCategoryForProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/product/${request['id']}/productToProductCategoryProductId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductToProductCategoryForProduct']} */
export const fairDbGetProductToProductCategoryForProduct = async (request) => {
  return await _fairDbGetProductToProductCategoryForProduct(baseUrl, request)
}
async function _fairDbGetProductOrderLineForProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/product/${request['id']}/productOrderLineProductId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrderLineForProduct']} */
export const fairDbGetProductOrderLineForProduct = async (request) => {
  return await _fairDbGetProductOrderLineForProduct(baseUrl, request)
}
async function _fairDbGetFairExecutionProductForProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/product/${request['id']}/fairExecutionProductProductId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionProductForProduct']} */
export const fairDbGetFairExecutionProductForProduct = async (request) => {
  return await _fairDbGetFairExecutionProductForProduct(baseUrl, request)
}
async function _fairDbGetProductSupplierForProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/product/${request['id']}/product_supplier?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductSupplierForProduct']} */
export const fairDbGetProductSupplierForProduct = async (request) => {
  return await _fairDbGetProductSupplierForProduct(baseUrl, request)
}
async function _fairDbGetProductToProductCategory (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.productCategoryId.eq', 'where.productCategoryId.neq', 'where.productCategoryId.gt', 'where.productCategoryId.gte', 'where.productCategoryId.lt', 'where.productCategoryId.lte', 'where.productCategoryId.like', 'where.productCategoryId.in', 'where.productCategoryId.nin', 'where.productCategoryId.contains', 'where.productCategoryId.contained', 'where.productCategoryId.overlaps', 'where.productId.eq', 'where.productId.neq', 'where.productId.gt', 'where.productId.gte', 'where.productId.lt', 'where.productId.lte', 'where.productId.like', 'where.productId.in', 'where.productId.nin', 'where.productId.contains', 'where.productId.contained', 'where.productId.overlaps', 'where.or', 'orderby.productCategoryId', 'orderby.productId']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productToProductCategory/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductToProductCategory']} */
export const fairDbGetProductToProductCategory = async (request) => {
  return await _fairDbGetProductToProductCategory(baseUrl, request)
}
async function _fairDbCreateProductToProductCategory (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productToProductCategory/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateProductToProductCategory']} */
export const fairDbCreateProductToProductCategory = async (request) => {
  return await _fairDbCreateProductToProductCategory(baseUrl, request)
}
async function _fairDbUpdateProductToProductCategory (url, request) {
  const queryParameters = ['fields', 'where.productCategoryId.eq', 'where.productCategoryId.neq', 'where.productCategoryId.gt', 'where.productCategoryId.gte', 'where.productCategoryId.lt', 'where.productCategoryId.lte', 'where.productCategoryId.like', 'where.productCategoryId.in', 'where.productCategoryId.nin', 'where.productCategoryId.contains', 'where.productCategoryId.contained', 'where.productCategoryId.overlaps', 'where.productId.eq', 'where.productId.neq', 'where.productId.gt', 'where.productId.gte', 'where.productId.lt', 'where.productId.lte', 'where.productId.like', 'where.productId.in', 'where.productId.nin', 'where.productId.contains', 'where.productId.contained', 'where.productId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productToProductCategory/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductToProductCategory']} */
export const fairDbUpdateProductToProductCategory = async (request) => {
  return await _fairDbUpdateProductToProductCategory(baseUrl, request)
}
async function _fairDbGetProductToProductCategoryByProductCategoryIdAndProductId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productToProductCategory/productCategory/${request['productCategoryId']}/product/${request['productId']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductToProductCategoryByProductCategoryIdAndProductId']} */
export const fairDbGetProductToProductCategoryByProductCategoryIdAndProductId = async (request) => {
  return await _fairDbGetProductToProductCategoryByProductCategoryIdAndProductId(baseUrl, request)
}
async function _postProductToProductCategoryProductCategoryProductCategoryIdProductProductId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productToProductCategory/productCategory/${request['productCategoryId']}/product/${request['productId']}?${searchParams.toString()}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['postProductToProductCategoryProductCategoryProductCategoryIdProductProductId']} */
export const postProductToProductCategoryProductCategoryProductCategoryIdProductProductId = async (request) => {
  return await _postProductToProductCategoryProductCategoryProductCategoryIdProductProductId(baseUrl, request)
}
async function _putProductToProductCategoryProductCategoryProductCategoryIdProductProductId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productToProductCategory/productCategory/${request['productCategoryId']}/product/${request['productId']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['putProductToProductCategoryProductCategoryProductCategoryIdProductProductId']} */
export const putProductToProductCategoryProductCategoryProductCategoryIdProductProductId = async (request) => {
  return await _putProductToProductCategoryProductCategoryProductCategoryIdProductProductId(baseUrl, request)
}
async function _deleteProductToProductCategoryProductCategoryProductCategoryIdProductProductId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productToProductCategory/productCategory/${request['productCategoryId']}/product/${request['productId']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['deleteProductToProductCategoryProductCategoryProductCategoryIdProductProductId']} */
export const deleteProductToProductCategoryProductCategoryProductCategoryIdProductProductId = async (request) => {
  return await _deleteProductToProductCategoryProductCategoryProductCategoryIdProductProductId(baseUrl, request)
}
async function _fairDbGetProductOrder (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.orderId.eq', 'where.orderId.neq', 'where.orderId.gt', 'where.orderId.gte', 'where.orderId.lt', 'where.orderId.lte', 'where.orderId.like', 'where.orderId.in', 'where.orderId.nin', 'where.orderId.contains', 'where.orderId.contained', 'where.orderId.overlaps', 'where.priceShipping.eq', 'where.priceShipping.neq', 'where.priceShipping.gt', 'where.priceShipping.gte', 'where.priceShipping.lt', 'where.priceShipping.lte', 'where.priceShipping.like', 'where.priceShipping.in', 'where.priceShipping.nin', 'where.priceShipping.contains', 'where.priceShipping.contained', 'where.priceShipping.overlaps', 'where.productSupplierId.eq', 'where.productSupplierId.neq', 'where.productSupplierId.gt', 'where.productSupplierId.gte', 'where.productSupplierId.lt', 'where.productSupplierId.lte', 'where.productSupplierId.like', 'where.productSupplierId.in', 'where.productSupplierId.nin', 'where.productSupplierId.contains', 'where.productSupplierId.contained', 'where.productSupplierId.overlaps', 'where.quantity.eq', 'where.quantity.neq', 'where.quantity.gt', 'where.quantity.gte', 'where.quantity.lt', 'where.quantity.lte', 'where.quantity.like', 'where.quantity.in', 'where.quantity.nin', 'where.quantity.contains', 'where.quantity.contained', 'where.quantity.overlaps', 'where.tmDelivery.eq', 'where.tmDelivery.neq', 'where.tmDelivery.gt', 'where.tmDelivery.gte', 'where.tmDelivery.lt', 'where.tmDelivery.lte', 'where.tmDelivery.like', 'where.tmDelivery.in', 'where.tmDelivery.nin', 'where.tmDelivery.contains', 'where.tmDelivery.contained', 'where.tmDelivery.overlaps', 'where.tmOrder.eq', 'where.tmOrder.neq', 'where.tmOrder.gt', 'where.tmOrder.gte', 'where.tmOrder.lt', 'where.tmOrder.lte', 'where.tmOrder.like', 'where.tmOrder.in', 'where.tmOrder.nin', 'where.tmOrder.contains', 'where.tmOrder.contained', 'where.tmOrder.overlaps', 'where.or', 'orderby.id', 'orderby.orderId', 'orderby.priceShipping', 'orderby.productSupplierId', 'orderby.quantity', 'orderby.tmDelivery', 'orderby.tmOrder']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productOrder/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrder']} */
export const fairDbGetProductOrder = async (request) => {
  return await _fairDbGetProductOrder(baseUrl, request)
}
async function _fairDbCreateProductOrder (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrder/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateProductOrder']} */
export const fairDbCreateProductOrder = async (request) => {
  return await _fairDbCreateProductOrder(baseUrl, request)
}
async function _fairDbUpdateProductOrder (url, request) {
  const queryParameters = ['fields', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.orderId.eq', 'where.orderId.neq', 'where.orderId.gt', 'where.orderId.gte', 'where.orderId.lt', 'where.orderId.lte', 'where.orderId.like', 'where.orderId.in', 'where.orderId.nin', 'where.orderId.contains', 'where.orderId.contained', 'where.orderId.overlaps', 'where.priceShipping.eq', 'where.priceShipping.neq', 'where.priceShipping.gt', 'where.priceShipping.gte', 'where.priceShipping.lt', 'where.priceShipping.lte', 'where.priceShipping.like', 'where.priceShipping.in', 'where.priceShipping.nin', 'where.priceShipping.contains', 'where.priceShipping.contained', 'where.priceShipping.overlaps', 'where.productSupplierId.eq', 'where.productSupplierId.neq', 'where.productSupplierId.gt', 'where.productSupplierId.gte', 'where.productSupplierId.lt', 'where.productSupplierId.lte', 'where.productSupplierId.like', 'where.productSupplierId.in', 'where.productSupplierId.nin', 'where.productSupplierId.contains', 'where.productSupplierId.contained', 'where.productSupplierId.overlaps', 'where.quantity.eq', 'where.quantity.neq', 'where.quantity.gt', 'where.quantity.gte', 'where.quantity.lt', 'where.quantity.lte', 'where.quantity.like', 'where.quantity.in', 'where.quantity.nin', 'where.quantity.contains', 'where.quantity.contained', 'where.quantity.overlaps', 'where.tmDelivery.eq', 'where.tmDelivery.neq', 'where.tmDelivery.gt', 'where.tmDelivery.gte', 'where.tmDelivery.lt', 'where.tmDelivery.lte', 'where.tmDelivery.like', 'where.tmDelivery.in', 'where.tmDelivery.nin', 'where.tmDelivery.contains', 'where.tmDelivery.contained', 'where.tmDelivery.overlaps', 'where.tmOrder.eq', 'where.tmOrder.neq', 'where.tmOrder.gt', 'where.tmOrder.gte', 'where.tmOrder.lt', 'where.tmOrder.lte', 'where.tmOrder.like', 'where.tmOrder.in', 'where.tmOrder.nin', 'where.tmOrder.contains', 'where.tmOrder.contained', 'where.tmOrder.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrder/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductOrder']} */
export const fairDbUpdateProductOrder = async (request) => {
  return await _fairDbUpdateProductOrder(baseUrl, request)
}
async function _fairDbGetProductOrderById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productOrder/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrderById']} */
export const fairDbGetProductOrderById = async (request) => {
  return await _fairDbGetProductOrderById(baseUrl, request)
}
async function _fairDbUpdateProductOrder (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrder/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductOrder']} */
export const fairDbUpdateProductOrder = async (request) => {
  return await _fairDbUpdateProductOrder(baseUrl, request)
}
async function _fairDbDeleteProductOrder (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrder/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteProductOrder']} */
export const fairDbDeleteProductOrder = async (request) => {
  return await _fairDbDeleteProductOrder(baseUrl, request)
}
async function _fairDbGetProductOrderLineForProductOrder (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productOrder/${request['id']}/productOrderLineProductOrderId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrderLineForProductOrder']} */
export const fairDbGetProductOrderLineForProductOrder = async (request) => {
  return await _fairDbGetProductOrderLineForProductOrder(baseUrl, request)
}
async function _fairDbGetProductSupplierForProductOrder (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productOrder/${request['id']}/product_supplier?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductSupplierForProductOrder']} */
export const fairDbGetProductSupplierForProductOrder = async (request) => {
  return await _fairDbGetProductSupplierForProductOrder(baseUrl, request)
}
async function _fairDbGetProductOrderLine (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.price.eq', 'where.price.neq', 'where.price.gt', 'where.price.gte', 'where.price.lt', 'where.price.lte', 'where.price.like', 'where.price.in', 'where.price.nin', 'where.price.contains', 'where.price.contained', 'where.price.overlaps', 'where.priceTaxRatePercent.eq', 'where.priceTaxRatePercent.neq', 'where.priceTaxRatePercent.gt', 'where.priceTaxRatePercent.gte', 'where.priceTaxRatePercent.lt', 'where.priceTaxRatePercent.lte', 'where.priceTaxRatePercent.like', 'where.priceTaxRatePercent.in', 'where.priceTaxRatePercent.nin', 'where.priceTaxRatePercent.contains', 'where.priceTaxRatePercent.contained', 'where.priceTaxRatePercent.overlaps', 'where.productId.eq', 'where.productId.neq', 'where.productId.gt', 'where.productId.gte', 'where.productId.lt', 'where.productId.lte', 'where.productId.like', 'where.productId.in', 'where.productId.nin', 'where.productId.contains', 'where.productId.contained', 'where.productId.overlaps', 'where.productOrderId.eq', 'where.productOrderId.neq', 'where.productOrderId.gt', 'where.productOrderId.gte', 'where.productOrderId.lt', 'where.productOrderId.lte', 'where.productOrderId.like', 'where.productOrderId.in', 'where.productOrderId.nin', 'where.productOrderId.contains', 'where.productOrderId.contained', 'where.productOrderId.overlaps', 'where.quantity.eq', 'where.quantity.neq', 'where.quantity.gt', 'where.quantity.gte', 'where.quantity.lt', 'where.quantity.lte', 'where.quantity.like', 'where.quantity.in', 'where.quantity.nin', 'where.quantity.contains', 'where.quantity.contained', 'where.quantity.overlaps', 'where.or', 'orderby.price', 'orderby.priceTaxRatePercent', 'orderby.productId', 'orderby.productOrderId', 'orderby.quantity']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productOrderLine/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrderLine']} */
export const fairDbGetProductOrderLine = async (request) => {
  return await _fairDbGetProductOrderLine(baseUrl, request)
}
async function _fairDbCreateProductOrderLine (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrderLine/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateProductOrderLine']} */
export const fairDbCreateProductOrderLine = async (request) => {
  return await _fairDbCreateProductOrderLine(baseUrl, request)
}
async function _fairDbUpdateProductOrderLine (url, request) {
  const queryParameters = ['fields', 'where.price.eq', 'where.price.neq', 'where.price.gt', 'where.price.gte', 'where.price.lt', 'where.price.lte', 'where.price.like', 'where.price.in', 'where.price.nin', 'where.price.contains', 'where.price.contained', 'where.price.overlaps', 'where.priceTaxRatePercent.eq', 'where.priceTaxRatePercent.neq', 'where.priceTaxRatePercent.gt', 'where.priceTaxRatePercent.gte', 'where.priceTaxRatePercent.lt', 'where.priceTaxRatePercent.lte', 'where.priceTaxRatePercent.like', 'where.priceTaxRatePercent.in', 'where.priceTaxRatePercent.nin', 'where.priceTaxRatePercent.contains', 'where.priceTaxRatePercent.contained', 'where.priceTaxRatePercent.overlaps', 'where.productId.eq', 'where.productId.neq', 'where.productId.gt', 'where.productId.gte', 'where.productId.lt', 'where.productId.lte', 'where.productId.like', 'where.productId.in', 'where.productId.nin', 'where.productId.contains', 'where.productId.contained', 'where.productId.overlaps', 'where.productOrderId.eq', 'where.productOrderId.neq', 'where.productOrderId.gt', 'where.productOrderId.gte', 'where.productOrderId.lt', 'where.productOrderId.lte', 'where.productOrderId.like', 'where.productOrderId.in', 'where.productOrderId.nin', 'where.productOrderId.contains', 'where.productOrderId.contained', 'where.productOrderId.overlaps', 'where.quantity.eq', 'where.quantity.neq', 'where.quantity.gt', 'where.quantity.gte', 'where.quantity.lt', 'where.quantity.lte', 'where.quantity.like', 'where.quantity.in', 'where.quantity.nin', 'where.quantity.contains', 'where.quantity.contained', 'where.quantity.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrderLine/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateProductOrderLine']} */
export const fairDbUpdateProductOrderLine = async (request) => {
  return await _fairDbUpdateProductOrderLine(baseUrl, request)
}
async function _fairDbGetProductOrderLineByProductIdAndProductOrderId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/productOrderLine/product/${request['productId']}/productOrder/${request['productOrderId']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductOrderLineByProductIdAndProductOrderId']} */
export const fairDbGetProductOrderLineByProductIdAndProductOrderId = async (request) => {
  return await _fairDbGetProductOrderLineByProductIdAndProductOrderId(baseUrl, request)
}
async function _postProductOrderLineProductProductIdProductOrderProductOrderId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrderLine/product/${request['productId']}/productOrder/${request['productOrderId']}?${searchParams.toString()}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['postProductOrderLineProductProductIdProductOrderProductOrderId']} */
export const postProductOrderLineProductProductIdProductOrderProductOrderId = async (request) => {
  return await _postProductOrderLineProductProductIdProductOrderProductOrderId(baseUrl, request)
}
async function _putProductOrderLineProductProductIdProductOrderProductOrderId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrderLine/product/${request['productId']}/productOrder/${request['productOrderId']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['putProductOrderLineProductProductIdProductOrderProductOrderId']} */
export const putProductOrderLineProductProductIdProductOrderProductOrderId = async (request) => {
  return await _putProductOrderLineProductProductIdProductOrderProductOrderId(baseUrl, request)
}
async function _deleteProductOrderLineProductProductIdProductOrderProductOrderId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/productOrderLine/product/${request['productId']}/productOrder/${request['productOrderId']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['deleteProductOrderLineProductProductIdProductOrderProductOrderId']} */
export const deleteProductOrderLineProductProductIdProductOrderProductOrderId = async (request) => {
  return await _deleteProductOrderLineProductProductIdProductOrderProductOrderId(baseUrl, request)
}
async function _fairDbGetFairPresenter (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.bic.eq', 'where.bic.neq', 'where.bic.gt', 'where.bic.gte', 'where.bic.lt', 'where.bic.lte', 'where.bic.like', 'where.bic.in', 'where.bic.nin', 'where.bic.contains', 'where.bic.contained', 'where.bic.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.homepage.eq', 'where.homepage.neq', 'where.homepage.gt', 'where.homepage.gte', 'where.homepage.lt', 'where.homepage.lte', 'where.homepage.like', 'where.homepage.in', 'where.homepage.nin', 'where.homepage.contains', 'where.homepage.contained', 'where.homepage.overlaps', 'where.iban.eq', 'where.iban.neq', 'where.iban.gt', 'where.iban.gte', 'where.iban.lt', 'where.iban.lte', 'where.iban.like', 'where.iban.in', 'where.iban.nin', 'where.iban.contains', 'where.iban.contained', 'where.iban.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.phone.eq', 'where.phone.neq', 'where.phone.gt', 'where.phone.gte', 'where.phone.lt', 'where.phone.lte', 'where.phone.like', 'where.phone.in', 'where.phone.nin', 'where.phone.contains', 'where.phone.contained', 'where.phone.overlaps', 'where.ratingFair.eq', 'where.ratingFair.neq', 'where.ratingFair.gt', 'where.ratingFair.gte', 'where.ratingFair.lt', 'where.ratingFair.lte', 'where.ratingFair.like', 'where.ratingFair.in', 'where.ratingFair.nin', 'where.ratingFair.contains', 'where.ratingFair.contained', 'where.ratingFair.overlaps', 'where.ratingPrice.eq', 'where.ratingPrice.neq', 'where.ratingPrice.gt', 'where.ratingPrice.gte', 'where.ratingPrice.lt', 'where.ratingPrice.lte', 'where.ratingPrice.like', 'where.ratingPrice.in', 'where.ratingPrice.nin', 'where.ratingPrice.contains', 'where.ratingPrice.contained', 'where.ratingPrice.overlaps', 'where.or', 'orderby.bic', 'orderby.description', 'orderby.homepage', 'orderby.iban', 'orderby.id', 'orderby.name', 'orderby.phone', 'orderby.ratingFair', 'orderby.ratingPrice']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairPresenter/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairPresenter']} */
export const fairDbGetFairPresenter = async (request) => {
  return await _fairDbGetFairPresenter(baseUrl, request)
}
async function _fairDbCreateFairPresenter (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairPresenter/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairPresenter']} */
export const fairDbCreateFairPresenter = async (request) => {
  return await _fairDbCreateFairPresenter(baseUrl, request)
}
async function _fairDbUpdateFairPresenter (url, request) {
  const queryParameters = ['fields', 'where.bic.eq', 'where.bic.neq', 'where.bic.gt', 'where.bic.gte', 'where.bic.lt', 'where.bic.lte', 'where.bic.like', 'where.bic.in', 'where.bic.nin', 'where.bic.contains', 'where.bic.contained', 'where.bic.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.homepage.eq', 'where.homepage.neq', 'where.homepage.gt', 'where.homepage.gte', 'where.homepage.lt', 'where.homepage.lte', 'where.homepage.like', 'where.homepage.in', 'where.homepage.nin', 'where.homepage.contains', 'where.homepage.contained', 'where.homepage.overlaps', 'where.iban.eq', 'where.iban.neq', 'where.iban.gt', 'where.iban.gte', 'where.iban.lt', 'where.iban.lte', 'where.iban.like', 'where.iban.in', 'where.iban.nin', 'where.iban.contains', 'where.iban.contained', 'where.iban.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.phone.eq', 'where.phone.neq', 'where.phone.gt', 'where.phone.gte', 'where.phone.lt', 'where.phone.lte', 'where.phone.like', 'where.phone.in', 'where.phone.nin', 'where.phone.contains', 'where.phone.contained', 'where.phone.overlaps', 'where.ratingFair.eq', 'where.ratingFair.neq', 'where.ratingFair.gt', 'where.ratingFair.gte', 'where.ratingFair.lt', 'where.ratingFair.lte', 'where.ratingFair.like', 'where.ratingFair.in', 'where.ratingFair.nin', 'where.ratingFair.contains', 'where.ratingFair.contained', 'where.ratingFair.overlaps', 'where.ratingPrice.eq', 'where.ratingPrice.neq', 'where.ratingPrice.gt', 'where.ratingPrice.gte', 'where.ratingPrice.lt', 'where.ratingPrice.lte', 'where.ratingPrice.like', 'where.ratingPrice.in', 'where.ratingPrice.nin', 'where.ratingPrice.contains', 'where.ratingPrice.contained', 'where.ratingPrice.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairPresenter/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairPresenter']} */
export const fairDbUpdateFairPresenter = async (request) => {
  return await _fairDbUpdateFairPresenter(baseUrl, request)
}
async function _fairDbGetFairPresenterById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairPresenter/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairPresenterById']} */
export const fairDbGetFairPresenterById = async (request) => {
  return await _fairDbGetFairPresenterById(baseUrl, request)
}
async function _fairDbUpdateFairPresenter (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairPresenter/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairPresenter']} */
export const fairDbUpdateFairPresenter = async (request) => {
  return await _fairDbUpdateFairPresenter(baseUrl, request)
}
async function _fairDbDeleteFairPresenter (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairPresenter/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairPresenter']} */
export const fairDbDeleteFairPresenter = async (request) => {
  return await _fairDbDeleteFairPresenter(baseUrl, request)
}
async function _fairDbGetFairForFairPresenter (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairPresenter/${request['id']}/fair?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairForFairPresenter']} */
export const fairDbGetFairForFairPresenter = async (request) => {
  return await _fairDbGetFairForFairPresenter(baseUrl, request)
}
async function _fairDbGetFairHelper (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.city.eq', 'where.city.neq', 'where.city.gt', 'where.city.gte', 'where.city.lt', 'where.city.lte', 'where.city.like', 'where.city.in', 'where.city.nin', 'where.city.contains', 'where.city.contained', 'where.city.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.phone.eq', 'where.phone.neq', 'where.phone.gt', 'where.phone.gte', 'where.phone.lt', 'where.phone.lte', 'where.phone.like', 'where.phone.in', 'where.phone.nin', 'where.phone.contains', 'where.phone.contained', 'where.phone.overlaps', 'where.ratingCut.eq', 'where.ratingCut.neq', 'where.ratingCut.gt', 'where.ratingCut.gte', 'where.ratingCut.lt', 'where.ratingCut.lte', 'where.ratingCut.like', 'where.ratingCut.in', 'where.ratingCut.nin', 'where.ratingCut.contains', 'where.ratingCut.contained', 'where.ratingCut.overlaps', 'where.ratingPlate.eq', 'where.ratingPlate.neq', 'where.ratingPlate.gt', 'where.ratingPlate.gte', 'where.ratingPlate.lt', 'where.ratingPlate.lte', 'where.ratingPlate.like', 'where.ratingPlate.in', 'where.ratingPlate.nin', 'where.ratingPlate.contains', 'where.ratingPlate.contained', 'where.ratingPlate.overlaps', 'where.ratingSell.eq', 'where.ratingSell.neq', 'where.ratingSell.gt', 'where.ratingSell.gte', 'where.ratingSell.lt', 'where.ratingSell.lte', 'where.ratingSell.like', 'where.ratingSell.in', 'where.ratingSell.nin', 'where.ratingSell.contains', 'where.ratingSell.contained', 'where.ratingSell.overlaps', 'where.street.eq', 'where.street.neq', 'where.street.gt', 'where.street.gte', 'where.street.lt', 'where.street.lte', 'where.street.like', 'where.street.in', 'where.street.nin', 'where.street.contains', 'where.street.contained', 'where.street.overlaps', 'where.usualWagePerDay.eq', 'where.usualWagePerDay.neq', 'where.usualWagePerDay.gt', 'where.usualWagePerDay.gte', 'where.usualWagePerDay.lt', 'where.usualWagePerDay.lte', 'where.usualWagePerDay.like', 'where.usualWagePerDay.in', 'where.usualWagePerDay.nin', 'where.usualWagePerDay.contains', 'where.usualWagePerDay.contained', 'where.usualWagePerDay.overlaps', 'where.usualWagePerHour.eq', 'where.usualWagePerHour.neq', 'where.usualWagePerHour.gt', 'where.usualWagePerHour.gte', 'where.usualWagePerHour.lt', 'where.usualWagePerHour.lte', 'where.usualWagePerHour.like', 'where.usualWagePerHour.in', 'where.usualWagePerHour.nin', 'where.usualWagePerHour.contains', 'where.usualWagePerHour.contained', 'where.usualWagePerHour.overlaps', 'where.or', 'orderby.city', 'orderby.id', 'orderby.name', 'orderby.notes', 'orderby.phone', 'orderby.ratingCut', 'orderby.ratingPlate', 'orderby.ratingSell', 'orderby.street', 'orderby.usualWagePerDay', 'orderby.usualWagePerHour']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairHelper/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairHelper']} */
export const fairDbGetFairHelper = async (request) => {
  return await _fairDbGetFairHelper(baseUrl, request)
}
async function _fairDbCreateFairHelper (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairHelper/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairHelper']} */
export const fairDbCreateFairHelper = async (request) => {
  return await _fairDbCreateFairHelper(baseUrl, request)
}
async function _fairDbUpdateFairHelper (url, request) {
  const queryParameters = ['fields', 'where.city.eq', 'where.city.neq', 'where.city.gt', 'where.city.gte', 'where.city.lt', 'where.city.lte', 'where.city.like', 'where.city.in', 'where.city.nin', 'where.city.contains', 'where.city.contained', 'where.city.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.phone.eq', 'where.phone.neq', 'where.phone.gt', 'where.phone.gte', 'where.phone.lt', 'where.phone.lte', 'where.phone.like', 'where.phone.in', 'where.phone.nin', 'where.phone.contains', 'where.phone.contained', 'where.phone.overlaps', 'where.ratingCut.eq', 'where.ratingCut.neq', 'where.ratingCut.gt', 'where.ratingCut.gte', 'where.ratingCut.lt', 'where.ratingCut.lte', 'where.ratingCut.like', 'where.ratingCut.in', 'where.ratingCut.nin', 'where.ratingCut.contains', 'where.ratingCut.contained', 'where.ratingCut.overlaps', 'where.ratingPlate.eq', 'where.ratingPlate.neq', 'where.ratingPlate.gt', 'where.ratingPlate.gte', 'where.ratingPlate.lt', 'where.ratingPlate.lte', 'where.ratingPlate.like', 'where.ratingPlate.in', 'where.ratingPlate.nin', 'where.ratingPlate.contains', 'where.ratingPlate.contained', 'where.ratingPlate.overlaps', 'where.ratingSell.eq', 'where.ratingSell.neq', 'where.ratingSell.gt', 'where.ratingSell.gte', 'where.ratingSell.lt', 'where.ratingSell.lte', 'where.ratingSell.like', 'where.ratingSell.in', 'where.ratingSell.nin', 'where.ratingSell.contains', 'where.ratingSell.contained', 'where.ratingSell.overlaps', 'where.street.eq', 'where.street.neq', 'where.street.gt', 'where.street.gte', 'where.street.lt', 'where.street.lte', 'where.street.like', 'where.street.in', 'where.street.nin', 'where.street.contains', 'where.street.contained', 'where.street.overlaps', 'where.usualWagePerDay.eq', 'where.usualWagePerDay.neq', 'where.usualWagePerDay.gt', 'where.usualWagePerDay.gte', 'where.usualWagePerDay.lt', 'where.usualWagePerDay.lte', 'where.usualWagePerDay.like', 'where.usualWagePerDay.in', 'where.usualWagePerDay.nin', 'where.usualWagePerDay.contains', 'where.usualWagePerDay.contained', 'where.usualWagePerDay.overlaps', 'where.usualWagePerHour.eq', 'where.usualWagePerHour.neq', 'where.usualWagePerHour.gt', 'where.usualWagePerHour.gte', 'where.usualWagePerHour.lt', 'where.usualWagePerHour.lte', 'where.usualWagePerHour.like', 'where.usualWagePerHour.in', 'where.usualWagePerHour.nin', 'where.usualWagePerHour.contains', 'where.usualWagePerHour.contained', 'where.usualWagePerHour.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairHelper/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairHelper']} */
export const fairDbUpdateFairHelper = async (request) => {
  return await _fairDbUpdateFairHelper(baseUrl, request)
}
async function _fairDbGetFairHelperById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairHelper/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairHelperById']} */
export const fairDbGetFairHelperById = async (request) => {
  return await _fairDbGetFairHelperById(baseUrl, request)
}
async function _fairDbUpdateFairHelper (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairHelper/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairHelper']} */
export const fairDbUpdateFairHelper = async (request) => {
  return await _fairDbUpdateFairHelper(baseUrl, request)
}
async function _fairDbDeleteFairHelper (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairHelper/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairHelper']} */
export const fairDbDeleteFairHelper = async (request) => {
  return await _fairDbDeleteFairHelper(baseUrl, request)
}
async function _fairDbGetFair (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.city.eq', 'where.city.neq', 'where.city.gt', 'where.city.gte', 'where.city.lt', 'where.city.lte', 'where.city.like', 'where.city.in', 'where.city.nin', 'where.city.contains', 'where.city.contained', 'where.city.overlaps', 'where.fairPresenterId.eq', 'where.fairPresenterId.neq', 'where.fairPresenterId.gt', 'where.fairPresenterId.gte', 'where.fairPresenterId.lt', 'where.fairPresenterId.lte', 'where.fairPresenterId.like', 'where.fairPresenterId.in', 'where.fairPresenterId.nin', 'where.fairPresenterId.contains', 'where.fairPresenterId.contained', 'where.fairPresenterId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.sellingHoursUsually.eq', 'where.sellingHoursUsually.neq', 'where.sellingHoursUsually.gt', 'where.sellingHoursUsually.gte', 'where.sellingHoursUsually.lt', 'where.sellingHoursUsually.lte', 'where.sellingHoursUsually.like', 'where.sellingHoursUsually.in', 'where.sellingHoursUsually.nin', 'where.sellingHoursUsually.contains', 'where.sellingHoursUsually.contained', 'where.sellingHoursUsually.overlaps', 'where.street.eq', 'where.street.neq', 'where.street.gt', 'where.street.gte', 'where.street.lt', 'where.street.lte', 'where.street.like', 'where.street.in', 'where.street.nin', 'where.street.contains', 'where.street.contained', 'where.street.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.usualPrice.eq', 'where.usualPrice.neq', 'where.usualPrice.gt', 'where.usualPrice.gte', 'where.usualPrice.lt', 'where.usualPrice.lte', 'where.usualPrice.like', 'where.usualPrice.in', 'where.usualPrice.nin', 'where.usualPrice.contains', 'where.usualPrice.contained', 'where.usualPrice.overlaps', 'where.usualTax.eq', 'where.usualTax.neq', 'where.usualTax.gt', 'where.usualTax.gte', 'where.usualTax.lt', 'where.usualTax.lte', 'where.usualTax.like', 'where.usualTax.in', 'where.usualTax.nin', 'where.usualTax.contains', 'where.usualTax.contained', 'where.usualTax.overlaps', 'where.or', 'orderby.city', 'orderby.fairPresenterId', 'orderby.id', 'orderby.notes', 'orderby.sellingHoursUsually', 'orderby.street', 'orderby.title', 'orderby.usualPrice', 'orderby.usualTax']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fair/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFair']} */
export const fairDbGetFair = async (request) => {
  return await _fairDbGetFair(baseUrl, request)
}
async function _fairDbCreateFair (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fair/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFair']} */
export const fairDbCreateFair = async (request) => {
  return await _fairDbCreateFair(baseUrl, request)
}
async function _fairDbUpdateFair (url, request) {
  const queryParameters = ['fields', 'where.city.eq', 'where.city.neq', 'where.city.gt', 'where.city.gte', 'where.city.lt', 'where.city.lte', 'where.city.like', 'where.city.in', 'where.city.nin', 'where.city.contains', 'where.city.contained', 'where.city.overlaps', 'where.fairPresenterId.eq', 'where.fairPresenterId.neq', 'where.fairPresenterId.gt', 'where.fairPresenterId.gte', 'where.fairPresenterId.lt', 'where.fairPresenterId.lte', 'where.fairPresenterId.like', 'where.fairPresenterId.in', 'where.fairPresenterId.nin', 'where.fairPresenterId.contains', 'where.fairPresenterId.contained', 'where.fairPresenterId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.sellingHoursUsually.eq', 'where.sellingHoursUsually.neq', 'where.sellingHoursUsually.gt', 'where.sellingHoursUsually.gte', 'where.sellingHoursUsually.lt', 'where.sellingHoursUsually.lte', 'where.sellingHoursUsually.like', 'where.sellingHoursUsually.in', 'where.sellingHoursUsually.nin', 'where.sellingHoursUsually.contains', 'where.sellingHoursUsually.contained', 'where.sellingHoursUsually.overlaps', 'where.street.eq', 'where.street.neq', 'where.street.gt', 'where.street.gte', 'where.street.lt', 'where.street.lte', 'where.street.like', 'where.street.in', 'where.street.nin', 'where.street.contains', 'where.street.contained', 'where.street.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.usualPrice.eq', 'where.usualPrice.neq', 'where.usualPrice.gt', 'where.usualPrice.gte', 'where.usualPrice.lt', 'where.usualPrice.lte', 'where.usualPrice.like', 'where.usualPrice.in', 'where.usualPrice.nin', 'where.usualPrice.contains', 'where.usualPrice.contained', 'where.usualPrice.overlaps', 'where.usualTax.eq', 'where.usualTax.neq', 'where.usualTax.gt', 'where.usualTax.gte', 'where.usualTax.lt', 'where.usualTax.lte', 'where.usualTax.like', 'where.usualTax.in', 'where.usualTax.nin', 'where.usualTax.contains', 'where.usualTax.contained', 'where.usualTax.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fair/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFair']} */
export const fairDbUpdateFair = async (request) => {
  return await _fairDbUpdateFair(baseUrl, request)
}
async function _fairDbGetFairById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fair/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairById']} */
export const fairDbGetFairById = async (request) => {
  return await _fairDbGetFairById(baseUrl, request)
}
async function _fairDbUpdateFair (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fair/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFair']} */
export const fairDbUpdateFair = async (request) => {
  return await _fairDbUpdateFair(baseUrl, request)
}
async function _fairDbDeleteFair (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fair/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFair']} */
export const fairDbDeleteFair = async (request) => {
  return await _fairDbDeleteFair(baseUrl, request)
}
async function _fairDbGetFairExecutionForFair (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fair/${request['id']}/fairExecution?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionForFair']} */
export const fairDbGetFairExecutionForFair = async (request) => {
  return await _fairDbGetFairExecutionForFair(baseUrl, request)
}
async function _fairDbGetFairExecutionDayForFair (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fair/${request['id']}/fairExecutionDay?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayForFair']} */
export const fairDbGetFairExecutionDayForFair = async (request) => {
  return await _fairDbGetFairExecutionDayForFair(baseUrl, request)
}
async function _fairDbGetFairPresenterForFair (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fair/${request['id']}/fair_presenter?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairPresenterForFair']} */
export const fairDbGetFairPresenterForFair = async (request) => {
  return await _fairDbGetFairPresenterForFair(baseUrl, request)
}
async function _fairDbGetFairExecution (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.black.eq', 'where.black.neq', 'where.black.gt', 'where.black.gte', 'where.black.lt', 'where.black.lte', 'where.black.like', 'where.black.in', 'where.black.nin', 'where.black.contains', 'where.black.contained', 'where.black.overlaps', 'where.fairId.eq', 'where.fairId.neq', 'where.fairId.gt', 'where.fairId.gte', 'where.fairId.lt', 'where.fairId.lte', 'where.fairId.like', 'where.fairId.in', 'where.fairId.nin', 'where.fairId.contains', 'where.fairId.contained', 'where.fairId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.tmFrom.eq', 'where.tmFrom.neq', 'where.tmFrom.gt', 'where.tmFrom.gte', 'where.tmFrom.lt', 'where.tmFrom.lte', 'where.tmFrom.like', 'where.tmFrom.in', 'where.tmFrom.nin', 'where.tmFrom.contains', 'where.tmFrom.contained', 'where.tmFrom.overlaps', 'where.tmTo.eq', 'where.tmTo.neq', 'where.tmTo.gt', 'where.tmTo.gte', 'where.tmTo.lt', 'where.tmTo.lte', 'where.tmTo.like', 'where.tmTo.in', 'where.tmTo.nin', 'where.tmTo.contains', 'where.tmTo.contained', 'where.tmTo.overlaps', 'where.or', 'orderby.black', 'orderby.fairId', 'orderby.id', 'orderby.notes', 'orderby.tmFrom', 'orderby.tmTo']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecution/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecution']} */
export const fairDbGetFairExecution = async (request) => {
  return await _fairDbGetFairExecution(baseUrl, request)
}
async function _fairDbCreateFairExecution (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecution/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairExecution']} */
export const fairDbCreateFairExecution = async (request) => {
  return await _fairDbCreateFairExecution(baseUrl, request)
}
async function _fairDbUpdateFairExecution (url, request) {
  const queryParameters = ['fields', 'where.black.eq', 'where.black.neq', 'where.black.gt', 'where.black.gte', 'where.black.lt', 'where.black.lte', 'where.black.like', 'where.black.in', 'where.black.nin', 'where.black.contains', 'where.black.contained', 'where.black.overlaps', 'where.fairId.eq', 'where.fairId.neq', 'where.fairId.gt', 'where.fairId.gte', 'where.fairId.lt', 'where.fairId.lte', 'where.fairId.like', 'where.fairId.in', 'where.fairId.nin', 'where.fairId.contains', 'where.fairId.contained', 'where.fairId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.tmFrom.eq', 'where.tmFrom.neq', 'where.tmFrom.gt', 'where.tmFrom.gte', 'where.tmFrom.lt', 'where.tmFrom.lte', 'where.tmFrom.like', 'where.tmFrom.in', 'where.tmFrom.nin', 'where.tmFrom.contains', 'where.tmFrom.contained', 'where.tmFrom.overlaps', 'where.tmTo.eq', 'where.tmTo.neq', 'where.tmTo.gt', 'where.tmTo.gte', 'where.tmTo.lt', 'where.tmTo.lte', 'where.tmTo.like', 'where.tmTo.in', 'where.tmTo.nin', 'where.tmTo.contains', 'where.tmTo.contained', 'where.tmTo.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecution/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecution']} */
export const fairDbUpdateFairExecution = async (request) => {
  return await _fairDbUpdateFairExecution(baseUrl, request)
}
async function _fairDbGetFairExecutionById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecution/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionById']} */
export const fairDbGetFairExecutionById = async (request) => {
  return await _fairDbGetFairExecutionById(baseUrl, request)
}
async function _fairDbUpdateFairExecution (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecution/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecution']} */
export const fairDbUpdateFairExecution = async (request) => {
  return await _fairDbUpdateFairExecution(baseUrl, request)
}
async function _fairDbDeleteFairExecution (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecution/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairExecution']} */
export const fairDbDeleteFairExecution = async (request) => {
  return await _fairDbDeleteFairExecution(baseUrl, request)
}
async function _fairDbGetFairForFairExecution (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecution/${request['id']}/fair?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairForFairExecution']} */
export const fairDbGetFairForFairExecution = async (request) => {
  return await _fairDbGetFairForFairExecution(baseUrl, request)
}
async function _fairDbGetFairExecutionDay (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.fairId.eq', 'where.fairId.neq', 'where.fairId.gt', 'where.fairId.gte', 'where.fairId.lt', 'where.fairId.lte', 'where.fairId.like', 'where.fairId.in', 'where.fairId.nin', 'where.fairId.contains', 'where.fairId.contained', 'where.fairId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.tmDay.eq', 'where.tmDay.neq', 'where.tmDay.gt', 'where.tmDay.gte', 'where.tmDay.lt', 'where.tmDay.lte', 'where.tmDay.like', 'where.tmDay.in', 'where.tmDay.nin', 'where.tmDay.contains', 'where.tmDay.contained', 'where.tmDay.overlaps', 'where.tmSellingHoursFrom.eq', 'where.tmSellingHoursFrom.neq', 'where.tmSellingHoursFrom.gt', 'where.tmSellingHoursFrom.gte', 'where.tmSellingHoursFrom.lt', 'where.tmSellingHoursFrom.lte', 'where.tmSellingHoursFrom.like', 'where.tmSellingHoursFrom.in', 'where.tmSellingHoursFrom.nin', 'where.tmSellingHoursFrom.contains', 'where.tmSellingHoursFrom.contained', 'where.tmSellingHoursFrom.overlaps', 'where.tmSellingHoursTo.eq', 'where.tmSellingHoursTo.neq', 'where.tmSellingHoursTo.gt', 'where.tmSellingHoursTo.gte', 'where.tmSellingHoursTo.lt', 'where.tmSellingHoursTo.lte', 'where.tmSellingHoursTo.like', 'where.tmSellingHoursTo.in', 'where.tmSellingHoursTo.nin', 'where.tmSellingHoursTo.contains', 'where.tmSellingHoursTo.contained', 'where.tmSellingHoursTo.overlaps', 'where.or', 'orderby.fairId', 'orderby.id', 'orderby.notes', 'orderby.tmDay', 'orderby.tmSellingHoursFrom', 'orderby.tmSellingHoursTo']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDay']} */
export const fairDbGetFairExecutionDay = async (request) => {
  return await _fairDbGetFairExecutionDay(baseUrl, request)
}
async function _fairDbCreateFairExecutionDay (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDay/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairExecutionDay']} */
export const fairDbCreateFairExecutionDay = async (request) => {
  return await _fairDbCreateFairExecutionDay(baseUrl, request)
}
async function _fairDbUpdateFairExecutionDay (url, request) {
  const queryParameters = ['fields', 'where.fairId.eq', 'where.fairId.neq', 'where.fairId.gt', 'where.fairId.gte', 'where.fairId.lt', 'where.fairId.lte', 'where.fairId.like', 'where.fairId.in', 'where.fairId.nin', 'where.fairId.contains', 'where.fairId.contained', 'where.fairId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.notes.eq', 'where.notes.neq', 'where.notes.gt', 'where.notes.gte', 'where.notes.lt', 'where.notes.lte', 'where.notes.like', 'where.notes.in', 'where.notes.nin', 'where.notes.contains', 'where.notes.contained', 'where.notes.overlaps', 'where.tmDay.eq', 'where.tmDay.neq', 'where.tmDay.gt', 'where.tmDay.gte', 'where.tmDay.lt', 'where.tmDay.lte', 'where.tmDay.like', 'where.tmDay.in', 'where.tmDay.nin', 'where.tmDay.contains', 'where.tmDay.contained', 'where.tmDay.overlaps', 'where.tmSellingHoursFrom.eq', 'where.tmSellingHoursFrom.neq', 'where.tmSellingHoursFrom.gt', 'where.tmSellingHoursFrom.gte', 'where.tmSellingHoursFrom.lt', 'where.tmSellingHoursFrom.lte', 'where.tmSellingHoursFrom.like', 'where.tmSellingHoursFrom.in', 'where.tmSellingHoursFrom.nin', 'where.tmSellingHoursFrom.contains', 'where.tmSellingHoursFrom.contained', 'where.tmSellingHoursFrom.overlaps', 'where.tmSellingHoursTo.eq', 'where.tmSellingHoursTo.neq', 'where.tmSellingHoursTo.gt', 'where.tmSellingHoursTo.gte', 'where.tmSellingHoursTo.lt', 'where.tmSellingHoursTo.lte', 'where.tmSellingHoursTo.like', 'where.tmSellingHoursTo.in', 'where.tmSellingHoursTo.nin', 'where.tmSellingHoursTo.contains', 'where.tmSellingHoursTo.contained', 'where.tmSellingHoursTo.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDay/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionDay']} */
export const fairDbUpdateFairExecutionDay = async (request) => {
  return await _fairDbUpdateFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairExecutionDayById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayById']} */
export const fairDbGetFairExecutionDayById = async (request) => {
  return await _fairDbGetFairExecutionDayById(baseUrl, request)
}
async function _fairDbUpdateFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionDay']} */
export const fairDbUpdateFairExecutionDay = async (request) => {
  return await _fairDbUpdateFairExecutionDay(baseUrl, request)
}
async function _fairDbDeleteFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairExecutionDay']} */
export const fairDbDeleteFairExecutionDay = async (request) => {
  return await _fairDbDeleteFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairExecutionProductForFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}/fairExecutionProductFairExecutionId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionProductForFairExecutionDay']} */
export const fairDbGetFairExecutionProductForFairExecutionDay = async (request) => {
  return await _fairDbGetFairExecutionProductForFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairExecutionDaySaleForFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}/fairExecutionDaySale?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDaySaleForFairExecutionDay']} */
export const fairDbGetFairExecutionDaySaleForFairExecutionDay = async (request) => {
  return await _fairDbGetFairExecutionDaySaleForFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairExecutionCostForFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}/fairExecutionCost?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionCostForFairExecutionDay']} */
export const fairDbGetFairExecutionCostForFairExecutionDay = async (request) => {
  return await _fairDbGetFairExecutionCostForFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairExecutionDayCostHelperForFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}/fairExecutionDayCostHelper?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayCostHelperForFairExecutionDay']} */
export const fairDbGetFairExecutionDayCostHelperForFairExecutionDay = async (request) => {
  return await _fairDbGetFairExecutionDayCostHelperForFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairForFairExecutionDay (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDay/${request['id']}/fair?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairForFairExecutionDay']} */
export const fairDbGetFairForFairExecutionDay = async (request) => {
  return await _fairDbGetFairForFairExecutionDay(baseUrl, request)
}
async function _fairDbGetFairExecutionProduct (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.fairExecutionId.eq', 'where.fairExecutionId.neq', 'where.fairExecutionId.gt', 'where.fairExecutionId.gte', 'where.fairExecutionId.lt', 'where.fairExecutionId.lte', 'where.fairExecutionId.like', 'where.fairExecutionId.in', 'where.fairExecutionId.nin', 'where.fairExecutionId.contains', 'where.fairExecutionId.contained', 'where.fairExecutionId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.productId.eq', 'where.productId.neq', 'where.productId.gt', 'where.productId.gte', 'where.productId.lt', 'where.productId.lte', 'where.productId.like', 'where.productId.in', 'where.productId.nin', 'where.productId.contains', 'where.productId.contained', 'where.productId.overlaps', 'where.quantityBack.eq', 'where.quantityBack.neq', 'where.quantityBack.gt', 'where.quantityBack.gte', 'where.quantityBack.lt', 'where.quantityBack.lte', 'where.quantityBack.like', 'where.quantityBack.in', 'where.quantityBack.nin', 'where.quantityBack.contains', 'where.quantityBack.contained', 'where.quantityBack.overlaps', 'where.quantityThere.eq', 'where.quantityThere.neq', 'where.quantityThere.gt', 'where.quantityThere.gte', 'where.quantityThere.lt', 'where.quantityThere.lte', 'where.quantityThere.like', 'where.quantityThere.in', 'where.quantityThere.nin', 'where.quantityThere.contains', 'where.quantityThere.contained', 'where.quantityThere.overlaps', 'where.or', 'orderby.fairExecutionId', 'orderby.id', 'orderby.productId', 'orderby.quantityBack', 'orderby.quantityThere']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionProduct/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionProduct']} */
export const fairDbGetFairExecutionProduct = async (request) => {
  return await _fairDbGetFairExecutionProduct(baseUrl, request)
}
async function _fairDbCreateFairExecutionProduct (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionProduct/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairExecutionProduct']} */
export const fairDbCreateFairExecutionProduct = async (request) => {
  return await _fairDbCreateFairExecutionProduct(baseUrl, request)
}
async function _fairDbUpdateFairExecutionProduct (url, request) {
  const queryParameters = ['fields', 'where.fairExecutionId.eq', 'where.fairExecutionId.neq', 'where.fairExecutionId.gt', 'where.fairExecutionId.gte', 'where.fairExecutionId.lt', 'where.fairExecutionId.lte', 'where.fairExecutionId.like', 'where.fairExecutionId.in', 'where.fairExecutionId.nin', 'where.fairExecutionId.contains', 'where.fairExecutionId.contained', 'where.fairExecutionId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.productId.eq', 'where.productId.neq', 'where.productId.gt', 'where.productId.gte', 'where.productId.lt', 'where.productId.lte', 'where.productId.like', 'where.productId.in', 'where.productId.nin', 'where.productId.contains', 'where.productId.contained', 'where.productId.overlaps', 'where.quantityBack.eq', 'where.quantityBack.neq', 'where.quantityBack.gt', 'where.quantityBack.gte', 'where.quantityBack.lt', 'where.quantityBack.lte', 'where.quantityBack.like', 'where.quantityBack.in', 'where.quantityBack.nin', 'where.quantityBack.contains', 'where.quantityBack.contained', 'where.quantityBack.overlaps', 'where.quantityThere.eq', 'where.quantityThere.neq', 'where.quantityThere.gt', 'where.quantityThere.gte', 'where.quantityThere.lt', 'where.quantityThere.lte', 'where.quantityThere.like', 'where.quantityThere.in', 'where.quantityThere.nin', 'where.quantityThere.contains', 'where.quantityThere.contained', 'where.quantityThere.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionProduct/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionProduct']} */
export const fairDbUpdateFairExecutionProduct = async (request) => {
  return await _fairDbUpdateFairExecutionProduct(baseUrl, request)
}
async function _fairDbGetFairExecutionProductById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionProduct/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionProductById']} */
export const fairDbGetFairExecutionProductById = async (request) => {
  return await _fairDbGetFairExecutionProductById(baseUrl, request)
}
async function _fairDbUpdateFairExecutionProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionProduct/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionProduct']} */
export const fairDbUpdateFairExecutionProduct = async (request) => {
  return await _fairDbUpdateFairExecutionProduct(baseUrl, request)
}
async function _fairDbDeleteFairExecutionProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionProduct/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairExecutionProduct']} */
export const fairDbDeleteFairExecutionProduct = async (request) => {
  return await _fairDbDeleteFairExecutionProduct(baseUrl, request)
}
async function _fairDbGetProductForFairExecutionProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionProduct/${request['id']}/product?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetProductForFairExecutionProduct']} */
export const fairDbGetProductForFairExecutionProduct = async (request) => {
  return await _fairDbGetProductForFairExecutionProduct(baseUrl, request)
}
async function _fairDbGetFairExecutionDayForFairExecutionProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionProduct/${request['id']}/fair_execution?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayForFairExecutionProduct']} */
export const fairDbGetFairExecutionDayForFairExecutionProduct = async (request) => {
  return await _fairDbGetFairExecutionDayForFairExecutionProduct(baseUrl, request)
}
async function _fairDbGetFairExecutionDaySale (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.fairExecutionDayId.eq', 'where.fairExecutionDayId.neq', 'where.fairExecutionDayId.gt', 'where.fairExecutionDayId.gte', 'where.fairExecutionDayId.lt', 'where.fairExecutionDayId.lte', 'where.fairExecutionDayId.like', 'where.fairExecutionDayId.in', 'where.fairExecutionDayId.nin', 'where.fairExecutionDayId.contains', 'where.fairExecutionDayId.contained', 'where.fairExecutionDayId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.salesCard.eq', 'where.salesCard.neq', 'where.salesCard.gt', 'where.salesCard.gte', 'where.salesCard.lt', 'where.salesCard.lte', 'where.salesCard.like', 'where.salesCard.in', 'where.salesCard.nin', 'where.salesCard.contains', 'where.salesCard.contained', 'where.salesCard.overlaps', 'where.salesCardTax.eq', 'where.salesCardTax.neq', 'where.salesCardTax.gt', 'where.salesCardTax.gte', 'where.salesCardTax.lt', 'where.salesCardTax.lte', 'where.salesCardTax.like', 'where.salesCardTax.in', 'where.salesCardTax.nin', 'where.salesCardTax.contains', 'where.salesCardTax.contained', 'where.salesCardTax.overlaps', 'where.salesCash.eq', 'where.salesCash.neq', 'where.salesCash.gt', 'where.salesCash.gte', 'where.salesCash.lt', 'where.salesCash.lte', 'where.salesCash.like', 'where.salesCash.in', 'where.salesCash.nin', 'where.salesCash.contains', 'where.salesCash.contained', 'where.salesCash.overlaps', 'where.salesCashTax.eq', 'where.salesCashTax.neq', 'where.salesCashTax.gt', 'where.salesCashTax.gte', 'where.salesCashTax.lt', 'where.salesCashTax.lte', 'where.salesCashTax.like', 'where.salesCashTax.in', 'where.salesCashTax.nin', 'where.salesCashTax.contains', 'where.salesCashTax.contained', 'where.salesCashTax.overlaps', 'where.or', 'orderby.fairExecutionDayId', 'orderby.id', 'orderby.salesCard', 'orderby.salesCardTax', 'orderby.salesCash', 'orderby.salesCashTax']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDaySale/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDaySale']} */
export const fairDbGetFairExecutionDaySale = async (request) => {
  return await _fairDbGetFairExecutionDaySale(baseUrl, request)
}
async function _fairDbCreateFairExecutionDaySale (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDaySale/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairExecutionDaySale']} */
export const fairDbCreateFairExecutionDaySale = async (request) => {
  return await _fairDbCreateFairExecutionDaySale(baseUrl, request)
}
async function _fairDbUpdateFairExecutionDaySale (url, request) {
  const queryParameters = ['fields', 'where.fairExecutionDayId.eq', 'where.fairExecutionDayId.neq', 'where.fairExecutionDayId.gt', 'where.fairExecutionDayId.gte', 'where.fairExecutionDayId.lt', 'where.fairExecutionDayId.lte', 'where.fairExecutionDayId.like', 'where.fairExecutionDayId.in', 'where.fairExecutionDayId.nin', 'where.fairExecutionDayId.contains', 'where.fairExecutionDayId.contained', 'where.fairExecutionDayId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.salesCard.eq', 'where.salesCard.neq', 'where.salesCard.gt', 'where.salesCard.gte', 'where.salesCard.lt', 'where.salesCard.lte', 'where.salesCard.like', 'where.salesCard.in', 'where.salesCard.nin', 'where.salesCard.contains', 'where.salesCard.contained', 'where.salesCard.overlaps', 'where.salesCardTax.eq', 'where.salesCardTax.neq', 'where.salesCardTax.gt', 'where.salesCardTax.gte', 'where.salesCardTax.lt', 'where.salesCardTax.lte', 'where.salesCardTax.like', 'where.salesCardTax.in', 'where.salesCardTax.nin', 'where.salesCardTax.contains', 'where.salesCardTax.contained', 'where.salesCardTax.overlaps', 'where.salesCash.eq', 'where.salesCash.neq', 'where.salesCash.gt', 'where.salesCash.gte', 'where.salesCash.lt', 'where.salesCash.lte', 'where.salesCash.like', 'where.salesCash.in', 'where.salesCash.nin', 'where.salesCash.contains', 'where.salesCash.contained', 'where.salesCash.overlaps', 'where.salesCashTax.eq', 'where.salesCashTax.neq', 'where.salesCashTax.gt', 'where.salesCashTax.gte', 'where.salesCashTax.lt', 'where.salesCashTax.lte', 'where.salesCashTax.like', 'where.salesCashTax.in', 'where.salesCashTax.nin', 'where.salesCashTax.contains', 'where.salesCashTax.contained', 'where.salesCashTax.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDaySale/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionDaySale']} */
export const fairDbUpdateFairExecutionDaySale = async (request) => {
  return await _fairDbUpdateFairExecutionDaySale(baseUrl, request)
}
async function _fairDbGetFairExecutionDaySaleById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDaySale/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDaySaleById']} */
export const fairDbGetFairExecutionDaySaleById = async (request) => {
  return await _fairDbGetFairExecutionDaySaleById(baseUrl, request)
}
async function _fairDbUpdateFairExecutionDaySale (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDaySale/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionDaySale']} */
export const fairDbUpdateFairExecutionDaySale = async (request) => {
  return await _fairDbUpdateFairExecutionDaySale(baseUrl, request)
}
async function _fairDbDeleteFairExecutionDaySale (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDaySale/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairExecutionDaySale']} */
export const fairDbDeleteFairExecutionDaySale = async (request) => {
  return await _fairDbDeleteFairExecutionDaySale(baseUrl, request)
}
async function _fairDbGetFairExecutionDayForFairExecutionDaySale (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDaySale/${request['id']}/fair_execution_day?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayForFairExecutionDaySale']} */
export const fairDbGetFairExecutionDayForFairExecutionDaySale = async (request) => {
  return await _fairDbGetFairExecutionDayForFairExecutionDaySale(baseUrl, request)
}
async function _fairDbGetFairExecutionCost (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.fairExecutionId.eq', 'where.fairExecutionId.neq', 'where.fairExecutionId.gt', 'where.fairExecutionId.gte', 'where.fairExecutionId.lt', 'where.fairExecutionId.lte', 'where.fairExecutionId.like', 'where.fairExecutionId.in', 'where.fairExecutionId.nin', 'where.fairExecutionId.contains', 'where.fairExecutionId.contained', 'where.fairExecutionId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.price.eq', 'where.price.neq', 'where.price.gt', 'where.price.gte', 'where.price.lt', 'where.price.lte', 'where.price.like', 'where.price.in', 'where.price.nin', 'where.price.contains', 'where.price.contained', 'where.price.overlaps', 'where.tax.eq', 'where.tax.neq', 'where.tax.gt', 'where.tax.gte', 'where.tax.lt', 'where.tax.lte', 'where.tax.like', 'where.tax.in', 'where.tax.nin', 'where.tax.contains', 'where.tax.contained', 'where.tax.overlaps', 'where.or', 'orderby.description', 'orderby.fairExecutionId', 'orderby.id', 'orderby.price', 'orderby.tax']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionCost/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionCost']} */
export const fairDbGetFairExecutionCost = async (request) => {
  return await _fairDbGetFairExecutionCost(baseUrl, request)
}
async function _fairDbCreateFairExecutionCost (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionCost/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairExecutionCost']} */
export const fairDbCreateFairExecutionCost = async (request) => {
  return await _fairDbCreateFairExecutionCost(baseUrl, request)
}
async function _fairDbUpdateFairExecutionCost (url, request) {
  const queryParameters = ['fields', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.fairExecutionId.eq', 'where.fairExecutionId.neq', 'where.fairExecutionId.gt', 'where.fairExecutionId.gte', 'where.fairExecutionId.lt', 'where.fairExecutionId.lte', 'where.fairExecutionId.like', 'where.fairExecutionId.in', 'where.fairExecutionId.nin', 'where.fairExecutionId.contains', 'where.fairExecutionId.contained', 'where.fairExecutionId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.price.eq', 'where.price.neq', 'where.price.gt', 'where.price.gte', 'where.price.lt', 'where.price.lte', 'where.price.like', 'where.price.in', 'where.price.nin', 'where.price.contains', 'where.price.contained', 'where.price.overlaps', 'where.tax.eq', 'where.tax.neq', 'where.tax.gt', 'where.tax.gte', 'where.tax.lt', 'where.tax.lte', 'where.tax.like', 'where.tax.in', 'where.tax.nin', 'where.tax.contains', 'where.tax.contained', 'where.tax.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionCost/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionCost']} */
export const fairDbUpdateFairExecutionCost = async (request) => {
  return await _fairDbUpdateFairExecutionCost(baseUrl, request)
}
async function _fairDbGetFairExecutionCostById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionCost/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionCostById']} */
export const fairDbGetFairExecutionCostById = async (request) => {
  return await _fairDbGetFairExecutionCostById(baseUrl, request)
}
async function _fairDbUpdateFairExecutionCost (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionCost/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionCost']} */
export const fairDbUpdateFairExecutionCost = async (request) => {
  return await _fairDbUpdateFairExecutionCost(baseUrl, request)
}
async function _fairDbDeleteFairExecutionCost (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionCost/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbDeleteFairExecutionCost']} */
export const fairDbDeleteFairExecutionCost = async (request) => {
  return await _fairDbDeleteFairExecutionCost(baseUrl, request)
}
async function _fairDbGetFairExecutionDayForFairExecutionCost (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionCost/${request['id']}/fair_execution?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayForFairExecutionCost']} */
export const fairDbGetFairExecutionDayForFairExecutionCost = async (request) => {
  return await _fairDbGetFairExecutionDayForFairExecutionCost(baseUrl, request)
}
async function _fairDbGetFairExecutionDayCostHelper (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.fairExecutionDayId.eq', 'where.fairExecutionDayId.neq', 'where.fairExecutionDayId.gt', 'where.fairExecutionDayId.gte', 'where.fairExecutionDayId.lt', 'where.fairExecutionDayId.lte', 'where.fairExecutionDayId.like', 'where.fairExecutionDayId.in', 'where.fairExecutionDayId.nin', 'where.fairExecutionDayId.contains', 'where.fairExecutionDayId.contained', 'where.fairExecutionDayId.overlaps', 'where.fairHelperId.eq', 'where.fairHelperId.neq', 'where.fairHelperId.gt', 'where.fairHelperId.gte', 'where.fairHelperId.lt', 'where.fairHelperId.lte', 'where.fairHelperId.like', 'where.fairHelperId.in', 'where.fairHelperId.nin', 'where.fairHelperId.contains', 'where.fairHelperId.contained', 'where.fairHelperId.overlaps', 'where.wage.eq', 'where.wage.neq', 'where.wage.gt', 'where.wage.gte', 'where.wage.lt', 'where.wage.lte', 'where.wage.like', 'where.wage.in', 'where.wage.nin', 'where.wage.contains', 'where.wage.contained', 'where.wage.overlaps', 'where.or', 'orderby.fairExecutionDayId', 'orderby.fairHelperId', 'orderby.wage']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayCostHelper']} */
export const fairDbGetFairExecutionDayCostHelper = async (request) => {
  return await _fairDbGetFairExecutionDayCostHelper(baseUrl, request)
}
async function _fairDbCreateFairExecutionDayCostHelper (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbCreateFairExecutionDayCostHelper']} */
export const fairDbCreateFairExecutionDayCostHelper = async (request) => {
  return await _fairDbCreateFairExecutionDayCostHelper(baseUrl, request)
}
async function _fairDbUpdateFairExecutionDayCostHelper (url, request) {
  const queryParameters = ['fields', 'where.fairExecutionDayId.eq', 'where.fairExecutionDayId.neq', 'where.fairExecutionDayId.gt', 'where.fairExecutionDayId.gte', 'where.fairExecutionDayId.lt', 'where.fairExecutionDayId.lte', 'where.fairExecutionDayId.like', 'where.fairExecutionDayId.in', 'where.fairExecutionDayId.nin', 'where.fairExecutionDayId.contains', 'where.fairExecutionDayId.contained', 'where.fairExecutionDayId.overlaps', 'where.fairHelperId.eq', 'where.fairHelperId.neq', 'where.fairHelperId.gt', 'where.fairHelperId.gte', 'where.fairHelperId.lt', 'where.fairHelperId.lte', 'where.fairHelperId.like', 'where.fairHelperId.in', 'where.fairHelperId.nin', 'where.fairHelperId.contains', 'where.fairHelperId.contained', 'where.fairHelperId.overlaps', 'where.wage.eq', 'where.wage.neq', 'where.wage.gt', 'where.wage.gte', 'where.wage.lt', 'where.wage.lte', 'where.wage.like', 'where.wage.in', 'where.wage.nin', 'where.wage.contains', 'where.wage.contained', 'where.wage.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbUpdateFairExecutionDayCostHelper']} */
export const fairDbUpdateFairExecutionDayCostHelper = async (request) => {
  return await _fairDbUpdateFairExecutionDayCostHelper(baseUrl, request)
}
async function _fairDbGetFairExecutionDayCostHelperByFairExecutionDayIdAndFairHelperId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/fairExecutionDay/${request['fairExecutionDayId']}/fairHelperId/${request['fairHelperId']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['fairDbGetFairExecutionDayCostHelperByFairExecutionDayIdAndFairHelperId']} */
export const fairDbGetFairExecutionDayCostHelperByFairExecutionDayIdAndFairHelperId = async (request) => {
  return await _fairDbGetFairExecutionDayCostHelperByFairExecutionDayIdAndFairHelperId(baseUrl, request)
}
async function _postFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/fairExecutionDay/${request['fairExecutionDayId']}/fairHelperId/${request['fairHelperId']}?${searchParams.toString()}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['postFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId']} */
export const postFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId = async (request) => {
  return await _postFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId(baseUrl, request)
}
async function _putFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/fairExecutionDay/${request['fairExecutionDayId']}/fairHelperId/${request['fairHelperId']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['putFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId']} */
export const putFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId = async (request) => {
  return await _putFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId(baseUrl, request)
}
async function _deleteFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/fairExecutionDayCostHelper/fairExecutionDay/${request['fairExecutionDayId']}/fairHelperId/${request['fairHelperId']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['deleteFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId']} */
export const deleteFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId = async (request) => {
  return await _deleteFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId(baseUrl, request)
}
async function _postExtractPdf (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/extract/pdf`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postExtractPdf']} */
export const postExtractPdf = async (request) => {
  return await _postExtractPdf(baseUrl, request)
}
async function _getAiImportTest (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/ai/import/test`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['getAiImportTest']} */
export const getAiImportTest = async (request) => {
  return await _getAiImportTest(baseUrl, request)
}
async function _postAiImportInvoiceGoodsFileId (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ai/import/invoice/goods/${request['fileId']}`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postAiImportInvoiceGoodsFileId']} */
export const postAiImportInvoiceGoodsFileId = async (request) => {
  return await _postAiImportInvoiceGoodsFileId(baseUrl, request)
}
async function _getAiTestAssistant (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/ai/test/assistant`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['getAiTestAssistant']} */
export const getAiTestAssistant = async (request) => {
  return await _getAiTestAssistant(baseUrl, request)
}
async function _postAiTestSupplier (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ai/test/supplier`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postAiTestSupplier']} */
export const postAiTestSupplier = async (request) => {
  return await _postAiTestSupplier(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    importDbGetFile: _importDbGetFile.bind(url, ...arguments),
    importDbCreateFile: _importDbCreateFile.bind(url, ...arguments),
    importDbUpdateFile: _importDbUpdateFile.bind(url, ...arguments),
    importDbGetFileById: _importDbGetFileById.bind(url, ...arguments),
    importDbUpdateFile: _importDbUpdateFile.bind(url, ...arguments),
    importDbDeleteFile: _importDbDeleteFile.bind(url, ...arguments),
    importDbGetFileExtractionForFile: _importDbGetFileExtractionForFile.bind(url, ...arguments),
    importDbGetFileTrainingForFile: _importDbGetFileTrainingForFile.bind(url, ...arguments),
    importDbGetFileExtraction: _importDbGetFileExtraction.bind(url, ...arguments),
    importDbCreateFileExtraction: _importDbCreateFileExtraction.bind(url, ...arguments),
    importDbUpdateFileExtraction: _importDbUpdateFileExtraction.bind(url, ...arguments),
    importDbGetFileExtractionById: _importDbGetFileExtractionById.bind(url, ...arguments),
    importDbUpdateFileExtraction: _importDbUpdateFileExtraction.bind(url, ...arguments),
    importDbDeleteFileExtraction: _importDbDeleteFileExtraction.bind(url, ...arguments),
    importDbGetFileForFileExtraction: _importDbGetFileForFileExtraction.bind(url, ...arguments),
    importDbGetFileTraining: _importDbGetFileTraining.bind(url, ...arguments),
    importDbCreateFileTraining: _importDbCreateFileTraining.bind(url, ...arguments),
    importDbUpdateFileTraining: _importDbUpdateFileTraining.bind(url, ...arguments),
    importDbGetFileTrainingById: _importDbGetFileTrainingById.bind(url, ...arguments),
    importDbUpdateFileTraining: _importDbUpdateFileTraining.bind(url, ...arguments),
    importDbDeleteFileTraining: _importDbDeleteFileTraining.bind(url, ...arguments),
    importDbGetFileForFileTraining: _importDbGetFileForFileTraining.bind(url, ...arguments),
    postImportInvoiceGoods: _postImportInvoiceGoods.bind(url, ...arguments),
    postImportTrainFileId: _postImportTrainFileId.bind(url, ...arguments),
    postImportModelFileId: _postImportModelFileId.bind(url, ...arguments),
    fairDbGetProductSupplier: _fairDbGetProductSupplier.bind(url, ...arguments),
    fairDbCreateProductSupplier: _fairDbCreateProductSupplier.bind(url, ...arguments),
    fairDbUpdateProductSupplier: _fairDbUpdateProductSupplier.bind(url, ...arguments),
    fairDbGetProductSupplierById: _fairDbGetProductSupplierById.bind(url, ...arguments),
    fairDbUpdateProductSupplier: _fairDbUpdateProductSupplier.bind(url, ...arguments),
    fairDbDeleteProductSupplier: _fairDbDeleteProductSupplier.bind(url, ...arguments),
    fairDbGetProductForProductSupplier: _fairDbGetProductForProductSupplier.bind(url, ...arguments),
    fairDbGetProductOrderForProductSupplier: _fairDbGetProductOrderForProductSupplier.bind(url, ...arguments),
    fairDbGetProductCategory: _fairDbGetProductCategory.bind(url, ...arguments),
    fairDbCreateProductCategory: _fairDbCreateProductCategory.bind(url, ...arguments),
    fairDbUpdateProductCategory: _fairDbUpdateProductCategory.bind(url, ...arguments),
    fairDbGetProductCategoryById: _fairDbGetProductCategoryById.bind(url, ...arguments),
    fairDbUpdateProductCategory: _fairDbUpdateProductCategory.bind(url, ...arguments),
    fairDbDeleteProductCategory: _fairDbDeleteProductCategory.bind(url, ...arguments),
    fairDbGetProductToProductCategoryForProductCategory: _fairDbGetProductToProductCategoryForProductCategory.bind(url, ...arguments),
    fairDbGetProduct: _fairDbGetProduct.bind(url, ...arguments),
    fairDbCreateProduct: _fairDbCreateProduct.bind(url, ...arguments),
    fairDbUpdateProduct: _fairDbUpdateProduct.bind(url, ...arguments),
    fairDbGetProductById: _fairDbGetProductById.bind(url, ...arguments),
    fairDbUpdateProduct: _fairDbUpdateProduct.bind(url, ...arguments),
    fairDbDeleteProduct: _fairDbDeleteProduct.bind(url, ...arguments),
    fairDbGetProductToProductCategoryForProduct: _fairDbGetProductToProductCategoryForProduct.bind(url, ...arguments),
    fairDbGetProductOrderLineForProduct: _fairDbGetProductOrderLineForProduct.bind(url, ...arguments),
    fairDbGetFairExecutionProductForProduct: _fairDbGetFairExecutionProductForProduct.bind(url, ...arguments),
    fairDbGetProductSupplierForProduct: _fairDbGetProductSupplierForProduct.bind(url, ...arguments),
    fairDbGetProductToProductCategory: _fairDbGetProductToProductCategory.bind(url, ...arguments),
    fairDbCreateProductToProductCategory: _fairDbCreateProductToProductCategory.bind(url, ...arguments),
    fairDbUpdateProductToProductCategory: _fairDbUpdateProductToProductCategory.bind(url, ...arguments),
    fairDbGetProductToProductCategoryByProductCategoryIdAndProductId: _fairDbGetProductToProductCategoryByProductCategoryIdAndProductId.bind(url, ...arguments),
    postProductToProductCategoryProductCategoryProductCategoryIdProductProductId: _postProductToProductCategoryProductCategoryProductCategoryIdProductProductId.bind(url, ...arguments),
    putProductToProductCategoryProductCategoryProductCategoryIdProductProductId: _putProductToProductCategoryProductCategoryProductCategoryIdProductProductId.bind(url, ...arguments),
    deleteProductToProductCategoryProductCategoryProductCategoryIdProductProductId: _deleteProductToProductCategoryProductCategoryProductCategoryIdProductProductId.bind(url, ...arguments),
    fairDbGetProductOrder: _fairDbGetProductOrder.bind(url, ...arguments),
    fairDbCreateProductOrder: _fairDbCreateProductOrder.bind(url, ...arguments),
    fairDbUpdateProductOrder: _fairDbUpdateProductOrder.bind(url, ...arguments),
    fairDbGetProductOrderById: _fairDbGetProductOrderById.bind(url, ...arguments),
    fairDbUpdateProductOrder: _fairDbUpdateProductOrder.bind(url, ...arguments),
    fairDbDeleteProductOrder: _fairDbDeleteProductOrder.bind(url, ...arguments),
    fairDbGetProductOrderLineForProductOrder: _fairDbGetProductOrderLineForProductOrder.bind(url, ...arguments),
    fairDbGetProductSupplierForProductOrder: _fairDbGetProductSupplierForProductOrder.bind(url, ...arguments),
    fairDbGetProductOrderLine: _fairDbGetProductOrderLine.bind(url, ...arguments),
    fairDbCreateProductOrderLine: _fairDbCreateProductOrderLine.bind(url, ...arguments),
    fairDbUpdateProductOrderLine: _fairDbUpdateProductOrderLine.bind(url, ...arguments),
    fairDbGetProductOrderLineByProductIdAndProductOrderId: _fairDbGetProductOrderLineByProductIdAndProductOrderId.bind(url, ...arguments),
    postProductOrderLineProductProductIdProductOrderProductOrderId: _postProductOrderLineProductProductIdProductOrderProductOrderId.bind(url, ...arguments),
    putProductOrderLineProductProductIdProductOrderProductOrderId: _putProductOrderLineProductProductIdProductOrderProductOrderId.bind(url, ...arguments),
    deleteProductOrderLineProductProductIdProductOrderProductOrderId: _deleteProductOrderLineProductProductIdProductOrderProductOrderId.bind(url, ...arguments),
    fairDbGetFairPresenter: _fairDbGetFairPresenter.bind(url, ...arguments),
    fairDbCreateFairPresenter: _fairDbCreateFairPresenter.bind(url, ...arguments),
    fairDbUpdateFairPresenter: _fairDbUpdateFairPresenter.bind(url, ...arguments),
    fairDbGetFairPresenterById: _fairDbGetFairPresenterById.bind(url, ...arguments),
    fairDbUpdateFairPresenter: _fairDbUpdateFairPresenter.bind(url, ...arguments),
    fairDbDeleteFairPresenter: _fairDbDeleteFairPresenter.bind(url, ...arguments),
    fairDbGetFairForFairPresenter: _fairDbGetFairForFairPresenter.bind(url, ...arguments),
    fairDbGetFairHelper: _fairDbGetFairHelper.bind(url, ...arguments),
    fairDbCreateFairHelper: _fairDbCreateFairHelper.bind(url, ...arguments),
    fairDbUpdateFairHelper: _fairDbUpdateFairHelper.bind(url, ...arguments),
    fairDbGetFairHelperById: _fairDbGetFairHelperById.bind(url, ...arguments),
    fairDbUpdateFairHelper: _fairDbUpdateFairHelper.bind(url, ...arguments),
    fairDbDeleteFairHelper: _fairDbDeleteFairHelper.bind(url, ...arguments),
    fairDbGetFair: _fairDbGetFair.bind(url, ...arguments),
    fairDbCreateFair: _fairDbCreateFair.bind(url, ...arguments),
    fairDbUpdateFair: _fairDbUpdateFair.bind(url, ...arguments),
    fairDbGetFairById: _fairDbGetFairById.bind(url, ...arguments),
    fairDbUpdateFair: _fairDbUpdateFair.bind(url, ...arguments),
    fairDbDeleteFair: _fairDbDeleteFair.bind(url, ...arguments),
    fairDbGetFairExecutionForFair: _fairDbGetFairExecutionForFair.bind(url, ...arguments),
    fairDbGetFairExecutionDayForFair: _fairDbGetFairExecutionDayForFair.bind(url, ...arguments),
    fairDbGetFairPresenterForFair: _fairDbGetFairPresenterForFair.bind(url, ...arguments),
    fairDbGetFairExecution: _fairDbGetFairExecution.bind(url, ...arguments),
    fairDbCreateFairExecution: _fairDbCreateFairExecution.bind(url, ...arguments),
    fairDbUpdateFairExecution: _fairDbUpdateFairExecution.bind(url, ...arguments),
    fairDbGetFairExecutionById: _fairDbGetFairExecutionById.bind(url, ...arguments),
    fairDbUpdateFairExecution: _fairDbUpdateFairExecution.bind(url, ...arguments),
    fairDbDeleteFairExecution: _fairDbDeleteFairExecution.bind(url, ...arguments),
    fairDbGetFairForFairExecution: _fairDbGetFairForFairExecution.bind(url, ...arguments),
    fairDbGetFairExecutionDay: _fairDbGetFairExecutionDay.bind(url, ...arguments),
    fairDbCreateFairExecutionDay: _fairDbCreateFairExecutionDay.bind(url, ...arguments),
    fairDbUpdateFairExecutionDay: _fairDbUpdateFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairExecutionDayById: _fairDbGetFairExecutionDayById.bind(url, ...arguments),
    fairDbUpdateFairExecutionDay: _fairDbUpdateFairExecutionDay.bind(url, ...arguments),
    fairDbDeleteFairExecutionDay: _fairDbDeleteFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairExecutionProductForFairExecutionDay: _fairDbGetFairExecutionProductForFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairExecutionDaySaleForFairExecutionDay: _fairDbGetFairExecutionDaySaleForFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairExecutionCostForFairExecutionDay: _fairDbGetFairExecutionCostForFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairExecutionDayCostHelperForFairExecutionDay: _fairDbGetFairExecutionDayCostHelperForFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairForFairExecutionDay: _fairDbGetFairForFairExecutionDay.bind(url, ...arguments),
    fairDbGetFairExecutionProduct: _fairDbGetFairExecutionProduct.bind(url, ...arguments),
    fairDbCreateFairExecutionProduct: _fairDbCreateFairExecutionProduct.bind(url, ...arguments),
    fairDbUpdateFairExecutionProduct: _fairDbUpdateFairExecutionProduct.bind(url, ...arguments),
    fairDbGetFairExecutionProductById: _fairDbGetFairExecutionProductById.bind(url, ...arguments),
    fairDbUpdateFairExecutionProduct: _fairDbUpdateFairExecutionProduct.bind(url, ...arguments),
    fairDbDeleteFairExecutionProduct: _fairDbDeleteFairExecutionProduct.bind(url, ...arguments),
    fairDbGetProductForFairExecutionProduct: _fairDbGetProductForFairExecutionProduct.bind(url, ...arguments),
    fairDbGetFairExecutionDayForFairExecutionProduct: _fairDbGetFairExecutionDayForFairExecutionProduct.bind(url, ...arguments),
    fairDbGetFairExecutionDaySale: _fairDbGetFairExecutionDaySale.bind(url, ...arguments),
    fairDbCreateFairExecutionDaySale: _fairDbCreateFairExecutionDaySale.bind(url, ...arguments),
    fairDbUpdateFairExecutionDaySale: _fairDbUpdateFairExecutionDaySale.bind(url, ...arguments),
    fairDbGetFairExecutionDaySaleById: _fairDbGetFairExecutionDaySaleById.bind(url, ...arguments),
    fairDbUpdateFairExecutionDaySale: _fairDbUpdateFairExecutionDaySale.bind(url, ...arguments),
    fairDbDeleteFairExecutionDaySale: _fairDbDeleteFairExecutionDaySale.bind(url, ...arguments),
    fairDbGetFairExecutionDayForFairExecutionDaySale: _fairDbGetFairExecutionDayForFairExecutionDaySale.bind(url, ...arguments),
    fairDbGetFairExecutionCost: _fairDbGetFairExecutionCost.bind(url, ...arguments),
    fairDbCreateFairExecutionCost: _fairDbCreateFairExecutionCost.bind(url, ...arguments),
    fairDbUpdateFairExecutionCost: _fairDbUpdateFairExecutionCost.bind(url, ...arguments),
    fairDbGetFairExecutionCostById: _fairDbGetFairExecutionCostById.bind(url, ...arguments),
    fairDbUpdateFairExecutionCost: _fairDbUpdateFairExecutionCost.bind(url, ...arguments),
    fairDbDeleteFairExecutionCost: _fairDbDeleteFairExecutionCost.bind(url, ...arguments),
    fairDbGetFairExecutionDayForFairExecutionCost: _fairDbGetFairExecutionDayForFairExecutionCost.bind(url, ...arguments),
    fairDbGetFairExecutionDayCostHelper: _fairDbGetFairExecutionDayCostHelper.bind(url, ...arguments),
    fairDbCreateFairExecutionDayCostHelper: _fairDbCreateFairExecutionDayCostHelper.bind(url, ...arguments),
    fairDbUpdateFairExecutionDayCostHelper: _fairDbUpdateFairExecutionDayCostHelper.bind(url, ...arguments),
    fairDbGetFairExecutionDayCostHelperByFairExecutionDayIdAndFairHelperId: _fairDbGetFairExecutionDayCostHelperByFairExecutionDayIdAndFairHelperId.bind(url, ...arguments),
    postFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId: _postFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId.bind(url, ...arguments),
    putFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId: _putFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId.bind(url, ...arguments),
    deleteFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId: _deleteFairExecutionDayCostHelperFairExecutionDayFairExecutionDayIdFairHelperIdFairHelperId.bind(url, ...arguments),
    postExtractPdf: _postExtractPdf.bind(url, ...arguments),
    getAiImportTest: _getAiImportTest.bind(url, ...arguments),
    postAiImportInvoiceGoodsFileId: _postAiImportInvoiceGoodsFileId.bind(url, ...arguments),
    getAiTestAssistant: _getAiTestAssistant.bind(url, ...arguments),
    postAiTestSupplier: _postAiTestSupplier.bind(url, ...arguments)
  }
}